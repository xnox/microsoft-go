From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: qmuntal <qmuntaldiaz@microsoft.com>
Date: Tue, 19 Jul 2022 15:58:02 +0200
Subject: [PATCH] Add CNG crypto backend

---
 src/cmd/api/boring_test.go                    |   2 +-
 src/cmd/go/go_boring_test.go                  |   2 +-
 src/crypto/boring/boring.go                   |   2 +-
 src/crypto/ecdsa/boring.go                    |   2 +-
 src/crypto/ecdsa/notboring.go                 |   2 +-
 src/crypto/internal/backend/backend_test.go   |   4 +-
 src/crypto/internal/backend/bbig/big.go       |   2 +-
 src/crypto/internal/backend/bbig/big_cng.go   |  12 +
 src/crypto/internal/backend/cng_windows.go    | 205 ++++++++++++++++++
 src/crypto/internal/backend/common.go         |  38 +++-
 src/crypto/internal/backend/nobackend.go      |   2 +-
 src/crypto/internal/boring/fipstls/stub.s     |   2 +-
 src/crypto/internal/boring/fipstls/tls.go     |   2 +-
 src/crypto/rand/rand_windows.go               |   9 +-
 src/crypto/rsa/boring.go                      |   2 +-
 src/crypto/rsa/boring_test.go                 |   2 +-
 src/crypto/rsa/notboring.go                   |   2 +-
 src/crypto/rsa/pkcs1v15.go                    |  16 +-
 src/crypto/rsa/pss.go                         |  12 +-
 src/crypto/rsa/pss_test.go                    |   2 +-
 src/crypto/rsa/rsa.go                         |  15 +-
 src/crypto/rsa/rsa_test.go                    |   8 +-
 src/crypto/sha1/boring.go                     |   5 +-
 src/crypto/sha1/notboring.go                  |   4 +-
 src/crypto/sha1/sha1_test.go                  |   7 +
 src/crypto/sha256/sha256.go                   |  12 +-
 src/crypto/sha256/sha256_test.go              |  10 +
 src/crypto/sha512/sha512_test.go              |  10 +
 src/crypto/tls/boring.go                      |   2 +-
 src/crypto/tls/boring_test.go                 |   2 +-
 src/crypto/tls/fipsonly/fipsonly.go           |   2 +-
 src/crypto/tls/fipsonly/fipsonly_test.go      |   2 +-
 src/crypto/tls/handshake_server_tls13.go      |  10 +
 src/crypto/tls/notboring.go                   |   2 +-
 src/crypto/x509/boring.go                     |   2 +-
 src/crypto/x509/boring_test.go                |   2 +-
 src/crypto/x509/notboring.go                  |   2 +-
 src/go.mod                                    |   1 +
 src/go.sum                                    |   2 +
 src/go/build/deps_test.go                     |   5 +
 src/hash/example_test.go                      |   2 +
 src/hash/marshal_test.go                      |   4 +
 .../goexperiment/exp_cngcrypto_off.go         |   9 +
 src/internal/goexperiment/exp_cngcrypto_on.go |   9 +
 src/internal/goexperiment/flags.go            |   1 +
 45 files changed, 405 insertions(+), 47 deletions(-)
 create mode 100644 src/crypto/internal/backend/bbig/big_cng.go
 create mode 100644 src/crypto/internal/backend/cng_windows.go
 create mode 100644 src/internal/goexperiment/exp_cngcrypto_off.go
 create mode 100644 src/internal/goexperiment/exp_cngcrypto_on.go

diff --git a/src/cmd/api/boring_test.go b/src/cmd/api/boring_test.go
index 01765f01736ccb..7598da96946b9f 100644
--- a/src/cmd/api/boring_test.go
+++ b/src/cmd/api/boring_test.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto || goexperiment.opensslcrypto
+//go:build boringcrypto || goexperiment.opensslcrypto || goexperiment.cngcrypto
 
 package api
 
diff --git a/src/cmd/go/go_boring_test.go b/src/cmd/go/go_boring_test.go
index 5376227f74cfaa..492ccf79d66b45 100644
--- a/src/cmd/go/go_boring_test.go
+++ b/src/cmd/go/go_boring_test.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto || goexperiment.opensslcrypto
+//go:build boringcrypto || goexperiment.opensslcrypto || goexperiment.cngcrypto
 
 package main_test
 
diff --git a/src/crypto/boring/boring.go b/src/crypto/boring/boring.go
index 7b04f14ebdd618..8bdafb72f2c51a 100644
--- a/src/crypto/boring/boring.go
+++ b/src/crypto/boring/boring.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto || goexperiment.opensslcrypto
+//go:build boringcrypto || goexperiment.opensslcrypto || goexperiment.cngcrypto
 
 // Package boring exposes functions that are only available when building with
 // Go+BoringCrypto. This package is available on all targets as long as the
diff --git a/src/crypto/ecdsa/boring.go b/src/crypto/ecdsa/boring.go
index 602cb894e20d39..bf9e77e06599f0 100644
--- a/src/crypto/ecdsa/boring.go
+++ b/src/crypto/ecdsa/boring.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto || goexperiment.opensslcrypto
+//go:build boringcrypto || goexperiment.opensslcrypto || goexperiment.cngcrypto
 
 package ecdsa
 
diff --git a/src/crypto/ecdsa/notboring.go b/src/crypto/ecdsa/notboring.go
index 3cc16ecab567a0..dbbc6e3897e153 100644
--- a/src/crypto/ecdsa/notboring.go
+++ b/src/crypto/ecdsa/notboring.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build !boringcrypto && !goexperiment.opensslcrypto
+//go:build !boringcrypto && !goexperiment.opensslcrypto && !goexperiment.cngcrypto
 
 package ecdsa
 
diff --git a/src/crypto/internal/backend/backend_test.go b/src/crypto/internal/backend/backend_test.go
index c2c06d3bff8c74..837cff477e257e 100644
--- a/src/crypto/internal/backend/backend_test.go
+++ b/src/crypto/internal/backend/backend_test.go
@@ -4,9 +4,7 @@
 
 package backend
 
-import (
-	"testing"
-)
+import "testing"
 
 // Test that Unreachable panics.
 func TestUnreachable(t *testing.T) {
diff --git a/src/crypto/internal/backend/bbig/big.go b/src/crypto/internal/backend/bbig/big.go
index 51bc3c68048d51..15f9833c9fcd20 100644
--- a/src/crypto/internal/backend/bbig/big.go
+++ b/src/crypto/internal/backend/bbig/big.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build !boringcrypto && !goexperiment.opensslcrypto
+//go:build !boringcrypto && !goexperiment.opensslcrypto && !goexperiment.cngcrypto
 
 package bbig
 
diff --git a/src/crypto/internal/backend/bbig/big_cng.go b/src/crypto/internal/backend/bbig/big_cng.go
new file mode 100644
index 00000000000000..92623031fd87d0
--- /dev/null
+++ b/src/crypto/internal/backend/bbig/big_cng.go
@@ -0,0 +1,12 @@
+// Copyright 2022 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build goexperiment.cngcrypto
+
+package bbig
+
+import "github.com/microsoft/go-crypto-winnative/cng/bbig"
+
+var Enc = bbig.Enc
+var Dec = bbig.Dec
diff --git a/src/crypto/internal/backend/cng_windows.go b/src/crypto/internal/backend/cng_windows.go
new file mode 100644
index 00000000000000..9d1bbf010c0fb6
--- /dev/null
+++ b/src/crypto/internal/backend/cng_windows.go
@@ -0,0 +1,205 @@
+// Copyright 2017 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build goexperiment.cngcrypto && windows && !cmd_go_bootstrap && !msan
+
+// Package cng provides access to CNGCrypto implementation functions.
+// Check the variable Enabled to find out whether CNGCrypto is available.
+// If CNGCrypto is not available, the functions in this package all panic.
+package backend
+
+import (
+	"crypto"
+	"crypto/cipher"
+	"crypto/internal/boring/sig"
+	"hash"
+	_ "unsafe"
+
+	"github.com/microsoft/go-crypto-winnative/cng"
+)
+
+// Enabled controls whether FIPS crypto is enabled.
+const Enabled = true
+
+func init() {
+	if v, ok := envGoFIPS(); ok && v == "1" {
+		enabled, err := cng.FIPS()
+		if err != nil {
+			panic("cngcrypto: unknown FIPS mode: " + err.Error())
+		}
+		if !enabled {
+			panic("cngcrypto: not in FIPS mode")
+		}
+	}
+	sig.BoringCrypto()
+}
+
+const RandReader = cng.RandReader
+
+func NewSHA1() hash.Hash {
+	return cng.NewSHA1()
+}
+
+func NewSHA224() hash.Hash { panic("cngcrypto: not available") }
+
+func NewSHA256() hash.Hash {
+	return cng.NewSHA256()
+}
+
+func NewSHA384() hash.Hash {
+	return cng.NewSHA384()
+}
+
+func NewSHA512() hash.Hash {
+	return cng.NewSHA512()
+}
+
+func SHA1(p []byte) (sum [20]byte) {
+	return cng.SHA1(p)
+}
+
+func SHA224(p []byte) (sum [28]byte) { panic("cngcrypto: not available") }
+
+func SHA256(p []byte) (sum [32]byte) {
+	return cng.SHA256(p)
+}
+
+func SHA384(p []byte) (sum [48]byte) {
+	return cng.SHA384(p)
+}
+
+func SHA512(p []byte) (sum [64]byte) {
+	return cng.SHA512(p)
+}
+
+func NewHMAC(h func() hash.Hash, key []byte) hash.Hash {
+	return cng.NewHMAC(h, key)
+}
+
+func NewAESCipher(key []byte) (cipher.Block, error) {
+	return cng.NewAESCipher(key)
+}
+
+func NewGCMTLS(c cipher.Block) (cipher.AEAD, error) {
+	return cng.NewGCMTLS(c)
+}
+
+type PublicKeyECDSA = cng.PublicKeyECDSA
+type PrivateKeyECDSA = cng.PrivateKeyECDSA
+
+func GenerateKeyECDSA(curve string) (X, Y, D cng.BigInt, err error) {
+	return cng.GenerateKeyECDSA(curve)
+}
+
+func NewPrivateKeyECDSA(curve string, X, Y, D cng.BigInt) (*cng.PrivateKeyECDSA, error) {
+	return cng.NewPrivateKeyECDSA(curve, X, Y, D)
+}
+
+func NewPublicKeyECDSA(curve string, X, Y cng.BigInt) (*cng.PublicKeyECDSA, error) {
+	return cng.NewPublicKeyECDSA(curve, X, Y)
+}
+
+//go:linkname encodeSignature crypto/ecdsa.encodeSignature
+func encodeSignature(r, s []byte) ([]byte, error)
+
+//go:linkname parseSignature crypto/ecdsa.parseSignature
+func parseSignature(sig []byte) (r, s []byte, err error)
+
+func SignMarshalECDSA(priv *cng.PrivateKeyECDSA, hash []byte) ([]byte, error) {
+	r, s, err := cng.SignECDSA(priv, hash)
+	if err != nil {
+		return nil, err
+	}
+	return encodeSignature(r, s)
+}
+
+func VerifyECDSA(pub *cng.PublicKeyECDSA, hash []byte, sig []byte) bool {
+	rBytes, sBytes, err := parseSignature(sig)
+	if err != nil {
+		return false
+	}
+	return cng.VerifyECDSA(pub, hash, cng.BigInt(rBytes), cng.BigInt(sBytes))
+}
+
+func SignECDSA(priv *cng.PrivateKeyECDSA, hash []byte) (r, s cng.BigInt, err error) {
+	return cng.SignECDSA(priv, hash)
+}
+
+func VerifyECDSARaw(pub *cng.PublicKeyECDSA, hash []byte, r, s cng.BigInt) bool {
+	return cng.VerifyECDSA(pub, hash, r, s)
+}
+
+type PublicKeyRSA = cng.PublicKeyRSA
+type PrivateKeyRSA = cng.PrivateKeyRSA
+
+func DecryptRSAOAEP(h, mgfHash hash.Hash, priv *cng.PrivateKeyRSA, ciphertext, label []byte) ([]byte, error) {
+	return cng.DecryptRSAOAEP(h, priv, ciphertext, label)
+}
+
+func DecryptRSAPKCS1(priv *cng.PrivateKeyRSA, ciphertext []byte) ([]byte, error) {
+	return cng.DecryptRSAPKCS1(priv, ciphertext)
+}
+
+func DecryptRSANoPadding(priv *cng.PrivateKeyRSA, ciphertext []byte) ([]byte, error) {
+	return cng.DecryptRSANoPadding(priv, ciphertext)
+}
+
+func EncryptRSAOAEP(h, mgfHash hash.Hash, pub *cng.PublicKeyRSA, msg, label []byte) ([]byte, error) {
+	return cng.EncryptRSAOAEP(h, pub, msg, label)
+}
+
+func EncryptRSAPKCS1(pub *cng.PublicKeyRSA, msg []byte) ([]byte, error) {
+	return cng.EncryptRSAPKCS1(pub, msg)
+}
+
+func EncryptRSANoPadding(pub *cng.PublicKeyRSA, msg []byte) ([]byte, error) {
+	return cng.EncryptRSANoPadding(pub, msg)
+}
+
+func GenerateKeyRSA(bits int) (N, E, D, P, Q, Dp, Dq, Qinv cng.BigInt, err error) {
+	return cng.GenerateKeyRSA(bits)
+}
+
+func NewPrivateKeyRSA(N, E, D, P, Q, Dp, Dq, Qinv cng.BigInt) (*cng.PrivateKeyRSA, error) {
+	return cng.NewPrivateKeyRSA(N, E, D, P, Q, Dp, Dq, Qinv)
+}
+
+func NewPublicKeyRSA(N, E cng.BigInt) (*cng.PublicKeyRSA, error) {
+	return cng.NewPublicKeyRSA(N, E)
+}
+
+func SignRSAPKCS1v15(priv *cng.PrivateKeyRSA, h crypto.Hash, hashed []byte) ([]byte, error) {
+	return cng.SignRSAPKCS1v15(priv, h, hashed)
+}
+
+func SignRSAPSS(priv *cng.PrivateKeyRSA, h crypto.Hash, hashed []byte, saltLen int) ([]byte, error) {
+	return cng.SignRSAPSS(priv, h, hashed, saltLen)
+}
+
+func VerifyRSAPKCS1v15(pub *cng.PublicKeyRSA, h crypto.Hash, hashed, sig []byte) error {
+	return cng.VerifyRSAPKCS1v15(pub, h, hashed, sig)
+}
+
+func VerifyRSAPSS(pub *cng.PublicKeyRSA, h crypto.Hash, hashed, sig []byte, saltLen int) error {
+	return cng.VerifyRSAPSS(pub, h, hashed, sig, saltLen)
+}
+
+type PrivateKeyECDH = cng.PrivateKeyECDH
+type PublicKeyECDH = cng.PublicKeyECDH
+
+func ECDH(priv *cng.PrivateKeyECDH, pub *cng.PublicKeyECDH) ([]byte, error) {
+	return cng.ECDH(priv, pub)
+}
+
+func GenerateKeyECDH(curve string) (*cng.PrivateKeyECDH, []byte, error) {
+	return cng.GenerateKeyECDH(curve)
+}
+
+func NewPrivateKeyECDH(curve string, bytes []byte) (*cng.PrivateKeyECDH, error) {
+	return cng.NewPrivateKeyECDH(curve, bytes)
+}
+
+func NewPublicKeyECDH(curve string, bytes []byte) (*cng.PublicKeyECDH, error) {
+	return cng.NewPublicKeyECDH(curve, bytes)
+}
diff --git a/src/crypto/internal/backend/common.go b/src/crypto/internal/backend/common.go
index 007d8070538247..114f72c3d10ee4 100644
--- a/src/crypto/internal/backend/common.go
+++ b/src/crypto/internal/backend/common.go
@@ -5,16 +5,19 @@
 package backend
 
 import (
+	"crypto"
 	"crypto/internal/boring/sig"
+	"internal/goexperiment"
 	"runtime"
 	"syscall"
 )
 
 func init() {
 	if v, _ := envGoFIPS(); v == "1" {
-		if runtime.GOOS != "linux" {
+		if runtime.GOOS != "linux" && runtime.GOOS != "windows" {
 			panic("FIPS mode requested (GOFIPS=1) but not supported on " + runtime.GOOS)
-		} else if !iscgo {
+		}
+		if runtime.GOOS == "linux" && !iscgo {
 			panic("FIPS mode requested (GOFIPS=1) but not supported with cgo disabled")
 		}
 	}
@@ -54,7 +57,11 @@ func hasSuffix(s, t string) bool {
 // UnreachableExceptTests marks code that should be unreachable
 // when backend is in use. It panics.
 func UnreachableExceptTests() {
-	if Enabled {
+	// runtime_arg0 is not supported on windows.
+	// We are going through the same code patch on linux,
+	// so if we are unintentionally calling an 'unreachable' function,
+	// we will catch it there.
+	if Enabled && !goexperiment.CNGCrypto {
 		name := runtime_arg0()
 		// If ran on Windows we'd need to allow _test.exe and .test.exe as well.
 		if !hasSuffix(name, "_test") && !hasSuffix(name, ".test") {
@@ -63,3 +70,28 @@ func UnreachableExceptTests() {
 		}
 	}
 }
+
+func IsRSAKeySupported(primes int) bool {
+	if goexperiment.CNGCrypto {
+		return primes == 2
+	}
+	return true
+}
+
+func IsHashSupported(h crypto.Hash) bool {
+	if goexperiment.CNGCrypto {
+		return h != crypto.MD5SHA1
+	}
+	return true
+}
+
+func IsSaltSupported(salt int) bool {
+	if goexperiment.CNGCrypto {
+		return salt != 0 // rsa.PSSSaltLengthAuto
+	}
+	return true
+}
+
+func IsP224Supported() bool {
+	return !goexperiment.CNGCrypto
+}
diff --git a/src/crypto/internal/backend/nobackend.go b/src/crypto/internal/backend/nobackend.go
index fcdea7f8ab5a9d..503e49212f972c 100644
--- a/src/crypto/internal/backend/nobackend.go
+++ b/src/crypto/internal/backend/nobackend.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build (!boringcrypto && !goexperiment.opensslcrypto) || !linux || !cgo || android || cmd_go_bootstrap || msan
+//go:build (!boringcrypto && !goexperiment.opensslcrypto && !goexperiment.cngcrypto) || (!linux && !windows) || (linux && !cgo) || android || cmd_go_bootstrap || msan
 
 package backend
 
diff --git a/src/crypto/internal/boring/fipstls/stub.s b/src/crypto/internal/boring/fipstls/stub.s
index 1dc7116efdff2e..b4c321d1d2babb 100644
--- a/src/crypto/internal/boring/fipstls/stub.s
+++ b/src/crypto/internal/boring/fipstls/stub.s
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto || goexperiment.opensslcrypto
+//go:build boringcrypto || goexperiment.opensslcrypto || goexperiment.cngcrypto
 
 // runtime_arg0 is declared in tls.go without a body.
 // It's provided by package runtime,
diff --git a/src/crypto/internal/boring/fipstls/tls.go b/src/crypto/internal/boring/fipstls/tls.go
index 4e629a4db8f7c7..a7cd24a0d15647 100644
--- a/src/crypto/internal/boring/fipstls/tls.go
+++ b/src/crypto/internal/boring/fipstls/tls.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto || goexperiment.opensslcrypto
+//go:build boringcrypto || goexperiment.opensslcrypto || goexperiment.cngcrypto
 
 // Package fipstls allows control over whether crypto/tls requires FIPS-approved settings.
 // This package only exists with GOEXPERIMENT=boringcrypto, but the effects are independent
diff --git a/src/crypto/rand/rand_windows.go b/src/crypto/rand/rand_windows.go
index 6c0655c72b692a..755861fc5bc21d 100644
--- a/src/crypto/rand/rand_windows.go
+++ b/src/crypto/rand/rand_windows.go
@@ -8,10 +8,17 @@
 package rand
 
 import (
+	boring "crypto/internal/backend"
 	"internal/syscall/windows"
 )
 
-func init() { Reader = &rngReader{} }
+func init() {
+	if boring.Enabled {
+		Reader = boring.RandReader
+		return
+	}
+	Reader = &rngReader{}
+}
 
 type rngReader struct{}
 
diff --git a/src/crypto/rsa/boring.go b/src/crypto/rsa/boring.go
index 220f8c05c3d94b..dd20b4af2e0472 100644
--- a/src/crypto/rsa/boring.go
+++ b/src/crypto/rsa/boring.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto || goexperiment.opensslcrypto
+//go:build boringcrypto || goexperiment.opensslcrypto || goexperiment.cngcrypto
 
 package rsa
 
diff --git a/src/crypto/rsa/boring_test.go b/src/crypto/rsa/boring_test.go
index 82a9d220e139af..c3860f8d698bc3 100644
--- a/src/crypto/rsa/boring_test.go
+++ b/src/crypto/rsa/boring_test.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto || goexperiment.opensslcrypto
+//go:build boringcrypto || goexperiment.opensslcrypto || goexperiment.cngcrypto
 
 // Note: Can run these tests against the non-BoringCrypto
 // version of the code by using "CGO_ENABLED=0 go test".
diff --git a/src/crypto/rsa/notboring.go b/src/crypto/rsa/notboring.go
index 933ac569e034a8..0f152b210fdd84 100644
--- a/src/crypto/rsa/notboring.go
+++ b/src/crypto/rsa/notboring.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build !boringcrypto && !goexperiment.opensslcrypto
+//go:build !boringcrypto && !goexperiment.opensslcrypto && !goexperiment.cngcrypto
 
 package rsa
 
diff --git a/src/crypto/rsa/pkcs1v15.go b/src/crypto/rsa/pkcs1v15.go
index 81c319d200a27a..be551d98c587fa 100644
--- a/src/crypto/rsa/pkcs1v15.go
+++ b/src/crypto/rsa/pkcs1v15.go
@@ -91,7 +91,9 @@ func DecryptPKCS1v15(random io.Reader, priv *PrivateKey, ciphertext []byte) ([]b
 		return nil, err
 	}
 
-	if boring.Enabled {
+	if boring.Enabled &&
+		boring.IsRSAKeySupported(len(priv.Primes)) {
+
 		bkey, err := boringPrivateKey(priv)
 		if err != nil {
 			return nil, err
@@ -185,7 +187,9 @@ func decryptPKCS1v15(priv *PrivateKey, ciphertext []byte) (valid int, em []byte,
 		return
 	}
 
-	if boring.Enabled {
+	if boring.Enabled &&
+		boring.IsRSAKeySupported(len(priv.Primes)) {
+
 		var bkey *boring.PrivateKeyRSA
 		bkey, err = boringPrivateKey(priv)
 		if err != nil {
@@ -293,7 +297,9 @@ func SignPKCS1v15(random io.Reader, priv *PrivateKey, hash crypto.Hash, hashed [
 		return nil, ErrMessageTooLong
 	}
 
-	if boring.Enabled {
+	if boring.Enabled &&
+		boring.IsHashSupported(hash) && boring.IsRSAKeySupported(len(priv.Primes)) {
+
 		bkey, err := boringPrivateKey(priv)
 		if err != nil {
 			return nil, err
@@ -319,7 +325,9 @@ func SignPKCS1v15(random io.Reader, priv *PrivateKey, hash crypto.Hash, hashed [
 // returning a nil error. If hash is zero then hashed is used directly. This
 // isn't advisable except for interoperability.
 func VerifyPKCS1v15(pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte) error {
-	if boring.Enabled {
+	if boring.Enabled &&
+		boring.IsHashSupported(hash) {
+
 		bkey, err := boringPublicKey(pub)
 		if err != nil {
 			return err
diff --git a/src/crypto/rsa/pss.go b/src/crypto/rsa/pss.go
index f2f2a64ed35e23..645434caf9c6d5 100644
--- a/src/crypto/rsa/pss.go
+++ b/src/crypto/rsa/pss.go
@@ -214,7 +214,9 @@ func signPSSWithSalt(priv *PrivateKey, hash crypto.Hash, hashed, salt []byte) ([
 		return nil, err
 	}
 
-	if boring.Enabled {
+	if boring.Enabled &&
+		boring.IsRSAKeySupported(len(priv.Primes)) {
+
 		bkey, err := boringPrivateKey(priv)
 		if err != nil {
 			return nil, err
@@ -286,7 +288,9 @@ var invalidSaltLenErr = errors.New("crypto/rsa: PSSOptions.SaltLength cannot be
 // function. The opts argument may be nil, in which case sensible defaults are
 // used. If opts.Hash is set, it overrides hash.
 func SignPSS(rand io.Reader, priv *PrivateKey, hash crypto.Hash, digest []byte, opts *PSSOptions) ([]byte, error) {
-	if boring.Enabled && rand == boring.RandReader {
+	if boring.Enabled && rand == boring.RandReader &&
+		boring.IsHashSupported(hash) && boring.IsRSAKeySupported(len(priv.Primes)) {
+
 		bkey, err := boringPrivateKey(priv)
 		if err != nil {
 			return nil, err
@@ -329,7 +333,9 @@ func SignPSS(rand io.Reader, priv *PrivateKey, hash crypto.Hash, digest []byte,
 // argument may be nil, in which case sensible defaults are used. opts.Hash is
 // ignored.
 func VerifyPSS(pub *PublicKey, hash crypto.Hash, digest []byte, sig []byte, opts *PSSOptions) error {
-	if boring.Enabled {
+	if boring.Enabled &&
+		boring.IsSaltSupported(opts.saltLength()) && boring.IsHashSupported(hash) {
+
 		bkey, err := boringPublicKey(pub)
 		if err != nil {
 			return err
diff --git a/src/crypto/rsa/pss_test.go b/src/crypto/rsa/pss_test.go
index cf03e3cb7ed2cc..361eab5db6137d 100644
--- a/src/crypto/rsa/pss_test.go
+++ b/src/crypto/rsa/pss_test.go
@@ -283,7 +283,7 @@ func fromHex(hexStr string) []byte {
 }
 
 func TestInvalidPSSSaltLength(t *testing.T) {
-	key, err := GenerateKey(rand.Reader, 245)
+	key, err := GenerateKey(rand.Reader, 512)
 	if err != nil {
 		t.Fatal(err)
 	}
diff --git a/src/crypto/rsa/rsa.go b/src/crypto/rsa/rsa.go
index 1124c6d09fbe18..1a14f5d2a9ae02 100644
--- a/src/crypto/rsa/rsa.go
+++ b/src/crypto/rsa/rsa.go
@@ -35,6 +35,7 @@ import (
 	"crypto/subtle"
 	"errors"
 	"hash"
+	"internal/goexperiment"
 	"io"
 	"math"
 	"math/big"
@@ -473,7 +474,11 @@ func mgf1XOR(out []byte, hash hash.Hash, seed []byte) {
 var ErrMessageTooLong = errors.New("crypto/rsa: message too long for RSA key size")
 
 func encrypt(pub *PublicKey, plaintext []byte) ([]byte, error) {
-	boring.Unreachable()
+	if !goexperiment.CNGCrypto {
+		// CNGCrypto calls encrypt() when the salt length
+		// or the hash function are not supported.
+		boring.Unreachable()
+	}
 
 	// Most of the CPU time for encryption and verification is spent in this
 	// NewModulusFromBig call, because PublicKey doesn't have a Precomputed
@@ -629,7 +634,9 @@ const noCheck = false
 // m^e is calculated and compared with ciphertext, in order to defend against
 // errors in the CRT computation.
 func decrypt(priv *PrivateKey, ciphertext []byte, check bool) ([]byte, error) {
-	if len(priv.Primes) <= 2 {
+	if len(priv.Primes) <= 2 && !goexperiment.CNGCrypto {
+		// CNGCrypto calls decrypt() when the salt length
+		// or the hash function are not supported.
 		boring.Unreachable()
 	}
 
@@ -709,7 +716,9 @@ func decryptOAEP(hash, mgfHash hash.Hash, random io.Reader, priv *PrivateKey, ci
 		return nil, ErrDecryption
 	}
 
-	if boring.Enabled {
+	if boring.Enabled &&
+		boring.IsRSAKeySupported(len(priv.Primes)) {
+
 		bkey, err := boringPrivateKey(priv)
 		if err != nil {
 			return nil, err
diff --git a/src/crypto/rsa/rsa_test.go b/src/crypto/rsa/rsa_test.go
index 3bb307e7bddc48..c9b5ab6d73b7af 100644
--- a/src/crypto/rsa/rsa_test.go
+++ b/src/crypto/rsa/rsa_test.go
@@ -17,6 +17,7 @@ import (
 	"encoding/pem"
 	"flag"
 	"fmt"
+	"internal/goexperiment"
 	"internal/testenv"
 	"math/big"
 	"strings"
@@ -113,6 +114,9 @@ func testKeyBasics(t *testing.T, priv *PrivateKey) {
 	if priv.D.Cmp(priv.N) > 0 {
 		t.Errorf("private exponent too large")
 	}
+	if goexperiment.CNGCrypto && priv.N.BitLen() < 512 {
+		t.Skip("CNGCrypto does not support key sizes lower than 512 and intentionally fails rather than fall back to Go crypto")
+	}
 
 	msg := []byte("hi!")
 	enc, err := EncryptPKCS1v15(rand.Reader, &priv.PublicKey, msg)
@@ -187,7 +191,9 @@ func testEverything(t *testing.T, priv *PrivateKey) {
 	if err := priv.Validate(); err != nil {
 		t.Errorf("Validate() failed: %s", err)
 	}
-
+	if goexperiment.CNGCrypto && priv.N.BitLen() < 512 {
+		t.Skip("CNGCrypto does not support key sizes lower than 512 and intentionally fails rather than fall back to Go crypto")
+	}
 	msg := []byte("test")
 	enc, err := EncryptPKCS1v15(rand.Reader, &priv.PublicKey, msg)
 	if err == ErrMessageTooLong {
diff --git a/src/crypto/sha1/boring.go b/src/crypto/sha1/boring.go
index e82a21c44a57c8..500b641dca6a1b 100644
--- a/src/crypto/sha1/boring.go
+++ b/src/crypto/sha1/boring.go
@@ -6,8 +6,9 @@
 // cmd/internal/boring is not even imported, so that we don't
 // have to maintain changes to cmd/dist's deps graph.
 
-//go:build !cmd_go_bootstrap && cgo
-// +build !cmd_go_bootstrap,cgo
+//go:build !cmd_go_bootstrap && (windows || cgo)
+// +build !cmd_go_bootstrap
+// +build windows cgo
 
 package sha1
 
diff --git a/src/crypto/sha1/notboring.go b/src/crypto/sha1/notboring.go
index 42ef87937faa34..9de147350c5f59 100644
--- a/src/crypto/sha1/notboring.go
+++ b/src/crypto/sha1/notboring.go
@@ -2,8 +2,8 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build cmd_go_bootstrap || !cgo
-// +build cmd_go_bootstrap !cgo
+//go:build cmd_go_bootstrap || (!cgo && !windows)
+// +build cmd_go_bootstrap !cgo,!windows
 
 package sha1
 
diff --git a/src/crypto/sha1/sha1_test.go b/src/crypto/sha1/sha1_test.go
index bc169888786321..e0d6f4c5040d91 100644
--- a/src/crypto/sha1/sha1_test.go
+++ b/src/crypto/sha1/sha1_test.go
@@ -13,6 +13,7 @@ import (
 	"encoding"
 	"fmt"
 	"hash"
+	"internal/goexperiment"
 	"io"
 	"testing"
 )
@@ -96,6 +97,9 @@ func TestGolden(t *testing.T) {
 }
 
 func TestGoldenMarshal(t *testing.T) {
+	if goexperiment.CNGCrypto {
+		t.Skip("CNGCrypto does not support hash marshalling")
+	}
 	h := New()
 	h2 := New()
 	for _, g := range golden {
@@ -197,6 +201,9 @@ func safeSum(h hash.Hash) (sum []byte, err error) {
 }
 
 func TestLargeHashes(t *testing.T) {
+	if goexperiment.CNGCrypto {
+		t.Skip("CNGCrypto does not support hash marshalling")
+	}
 	for i, test := range largeUnmarshalTests {
 
 		h := New()
diff --git a/src/crypto/sha256/sha256.go b/src/crypto/sha256/sha256.go
index b6fd0c3aab5100..fa246e9ecf65ba 100644
--- a/src/crypto/sha256/sha256.go
+++ b/src/crypto/sha256/sha256.go
@@ -158,7 +158,7 @@ func New() hash.Hash {
 
 // New224 returns a new hash.Hash computing the SHA224 checksum.
 func New224() hash.Hash {
-	if boring.Enabled {
+	if boring.Enabled && boring.IsP224Supported() {
 		return boring.NewSHA224()
 	}
 	d := new(digest)
@@ -177,7 +177,9 @@ func (d *digest) Size() int {
 func (d *digest) BlockSize() int { return BlockSize }
 
 func (d *digest) Write(p []byte) (nn int, err error) {
-	boring.Unreachable()
+	if boring.Enabled && (!d.is224 || boring.IsP224Supported()) {
+		boring.Unreachable()
+	}
 	nn = len(p)
 	d.len += uint64(nn)
 	if d.nx > 0 {
@@ -201,7 +203,9 @@ func (d *digest) Write(p []byte) (nn int, err error) {
 }
 
 func (d *digest) Sum(in []byte) []byte {
-	boring.Unreachable()
+	if boring.Enabled && (!d.is224 || boring.IsP224Supported()) {
+		boring.Unreachable()
+	}
 	// Make a copy of d so that caller can keep writing and summing.
 	d0 := *d
 	hash := d0.checkSum()
@@ -262,7 +266,7 @@ func Sum256(data []byte) [Size]byte {
 
 // Sum224 returns the SHA224 checksum of the data.
 func Sum224(data []byte) [Size224]byte {
-	if boring.Enabled {
+	if boring.Enabled && boring.IsP224Supported() {
 		return boring.SHA224(data)
 	}
 	var d digest
diff --git a/src/crypto/sha256/sha256_test.go b/src/crypto/sha256/sha256_test.go
index 7437655badee23..95c8688904c088 100644
--- a/src/crypto/sha256/sha256_test.go
+++ b/src/crypto/sha256/sha256_test.go
@@ -13,6 +13,7 @@ import (
 	"encoding"
 	"fmt"
 	"hash"
+	"internal/goexperiment"
 	"io"
 	"testing"
 )
@@ -139,6 +140,9 @@ func TestGolden(t *testing.T) {
 }
 
 func TestGoldenMarshal(t *testing.T) {
+	if goexperiment.CNGCrypto {
+		t.Skip("CNGCrypto does not support hash marshalling")
+	}
 	tests := []struct {
 		name    string
 		newHash func() hash.Hash
@@ -184,6 +188,9 @@ func TestGoldenMarshal(t *testing.T) {
 }
 
 func TestMarshalTypeMismatch(t *testing.T) {
+	if goexperiment.CNGCrypto {
+		t.Skip("CNGCrypto does not support hash marshalling")
+	}
 	h1 := New()
 	h2 := New224()
 
@@ -273,6 +280,9 @@ func safeSum(h hash.Hash) (sum []byte, err error) {
 	return h.Sum(nil), nil
 }
 func TestLargeHashes(t *testing.T) {
+	if goexperiment.CNGCrypto {
+		t.Skip("CNGCrypto does not support hash marshalling")
+	}
 	for i, test := range largeUnmarshalTests {
 
 		h := New()
diff --git a/src/crypto/sha512/sha512_test.go b/src/crypto/sha512/sha512_test.go
index 2fef7ddae07480..979e4c69ab710c 100644
--- a/src/crypto/sha512/sha512_test.go
+++ b/src/crypto/sha512/sha512_test.go
@@ -14,6 +14,7 @@ import (
 	"encoding/hex"
 	"fmt"
 	"hash"
+	"internal/goexperiment"
 	"io"
 	"testing"
 )
@@ -719,6 +720,9 @@ func TestGolden(t *testing.T) {
 }
 
 func TestGoldenMarshal(t *testing.T) {
+	if goexperiment.CNGCrypto {
+		t.Skip("CNGCrypto does not support hash marshalling")
+	}
 	tests := []struct {
 		name    string
 		newHash func() hash.Hash
@@ -766,6 +770,9 @@ func TestGoldenMarshal(t *testing.T) {
 }
 
 func TestMarshalMismatch(t *testing.T) {
+	if goexperiment.CNGCrypto {
+		t.Skip("CNGCrypto does not support hash marshaling")
+	}
 	h := []func() hash.Hash{
 		New,
 		New384,
@@ -872,6 +879,9 @@ func safeSum(h hash.Hash) (sum []byte, err error) {
 }
 
 func TestLargeHashes(t *testing.T) {
+	if goexperiment.CNGCrypto {
+		t.Skip("CNGCrypto does not support hash marshalling")
+	}
 	for i, test := range largeUnmarshalTests {
 
 		h := New()
diff --git a/src/crypto/tls/boring.go b/src/crypto/tls/boring.go
index 70baa62d63754a..ecd0f5a7b3e9ed 100644
--- a/src/crypto/tls/boring.go
+++ b/src/crypto/tls/boring.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto || goexperiment.opensslcrypto
+//go:build boringcrypto || goexperiment.opensslcrypto || goexperiment.cngcrypto
 
 package tls
 
diff --git a/src/crypto/tls/boring_test.go b/src/crypto/tls/boring_test.go
index 929111d8679cc2..3e63ba6a053c42 100644
--- a/src/crypto/tls/boring_test.go
+++ b/src/crypto/tls/boring_test.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto || goexperiment.opensslcrypto
+//go:build boringcrypto || goexperiment.opensslcrypto || goexperiment.cngcrypto
 
 package tls
 
diff --git a/src/crypto/tls/fipsonly/fipsonly.go b/src/crypto/tls/fipsonly/fipsonly.go
index 1a94656dfee6dd..d7d1441ed319be 100644
--- a/src/crypto/tls/fipsonly/fipsonly.go
+++ b/src/crypto/tls/fipsonly/fipsonly.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto || goexperiment.opensslcrypto
+//go:build boringcrypto || goexperiment.opensslcrypto || goexperiment.cngcrypto
 
 // Package fipsonly restricts all TLS configuration to FIPS-approved settings.
 //
diff --git a/src/crypto/tls/fipsonly/fipsonly_test.go b/src/crypto/tls/fipsonly/fipsonly_test.go
index 9c1d3d279c472f..0ca7a863b73690 100644
--- a/src/crypto/tls/fipsonly/fipsonly_test.go
+++ b/src/crypto/tls/fipsonly/fipsonly_test.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto || goexperiment.opensslcrypto
+//go:build boringcrypto || goexperiment.opensslcrypto || goexperiment.cngcrypto
 
 package fipsonly
 
diff --git a/src/crypto/tls/handshake_server_tls13.go b/src/crypto/tls/handshake_server_tls13.go
index 07b1a3851e0714..6fae2b4ba22540 100644
--- a/src/crypto/tls/handshake_server_tls13.go
+++ b/src/crypto/tls/handshake_server_tls13.go
@@ -13,6 +13,7 @@ import (
 	"encoding/binary"
 	"errors"
 	"hash"
+	"internal/goexperiment"
 	"io"
 	"time"
 )
@@ -402,6 +403,15 @@ func cloneHash(in hash.Hash, h crypto.Hash) hash.Hash {
 	}
 	marshaler, ok := in.(binaryMarshaler)
 	if !ok {
+		if goexperiment.CNGCrypto {
+			// CNGCrypto hashes do not implement the binaryMarshaler interface,
+			// but do implement the Clone method.
+			if cloner, ok := in.(interface{ Clone() (hash.Hash, error) }); ok {
+				if out, err := cloner.Clone(); err == nil {
+					return out
+				}
+			}
+		}
 		return nil
 	}
 	state, err := marshaler.MarshalBinary()
diff --git a/src/crypto/tls/notboring.go b/src/crypto/tls/notboring.go
index 1aaabd5ef486aa..5a133c9b2f94c7 100644
--- a/src/crypto/tls/notboring.go
+++ b/src/crypto/tls/notboring.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build !boringcrypto && !goexperiment.opensslcrypto
+//go:build !boringcrypto && !goexperiment.opensslcrypto && !goexperiment.cngcrypto
 
 package tls
 
diff --git a/src/crypto/x509/boring.go b/src/crypto/x509/boring.go
index 9aec21dbcd3bff..05324f731bedc4 100644
--- a/src/crypto/x509/boring.go
+++ b/src/crypto/x509/boring.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto || goexperiment.opensslcrypto
+//go:build boringcrypto || goexperiment.opensslcrypto || goexperiment.cngcrypto
 
 package x509
 
diff --git a/src/crypto/x509/boring_test.go b/src/crypto/x509/boring_test.go
index e8fce393d29b00..9818c9b7d6b6b8 100644
--- a/src/crypto/x509/boring_test.go
+++ b/src/crypto/x509/boring_test.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto || goexperiment.opensslcrypto
+//go:build boringcrypto || goexperiment.opensslcrypto || goexperiment.cngcrypto
 
 package x509
 
diff --git a/src/crypto/x509/notboring.go b/src/crypto/x509/notboring.go
index a0548a7f9179c5..ae6117a1554b7f 100644
--- a/src/crypto/x509/notboring.go
+++ b/src/crypto/x509/notboring.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build !boringcrypto && !goexperiment.opensslcrypto
+//go:build !boringcrypto && !goexperiment.opensslcrypto && !goexperiment.cngcrypto
 
 package x509
 
diff --git a/src/go.mod b/src/go.mod
index b73f25f582d963..554c8336e0a447 100644
--- a/src/go.mod
+++ b/src/go.mod
@@ -4,6 +4,7 @@ go 1.21
 
 require (
 	github.com/golang-fips/openssl v0.0.0-20230603145912-70dc5503554b
+	github.com/microsoft/go-crypto-winnative v0.0.0-20230502061212-6eb98854418e
 	golang.org/x/crypto v0.9.0
 	golang.org/x/net v0.10.1-0.20230525180353-f7250ea19d21
 )
diff --git a/src/go.sum b/src/go.sum
index 5de425188d93c2..37d6563a8a7539 100644
--- a/src/go.sum
+++ b/src/go.sum
@@ -1,5 +1,7 @@
 github.com/golang-fips/openssl v0.0.0-20230603145912-70dc5503554b h1:Ih7ypZiBez+G9j5zrAI6WWnfxMdx4Yk6RcaSvMAdu8A=
 github.com/golang-fips/openssl v0.0.0-20230603145912-70dc5503554b/go.mod h1:LBziBt5PA8FeliZ0KnhnWMrrHzvAsMWZUlYWOYKkpBI=
+github.com/microsoft/go-crypto-winnative v0.0.0-20230502061212-6eb98854418e h1:BB2UybwbUjtxG2OFs6KnKi8AOlk9rjH7ekjkbW+vHA0=
+github.com/microsoft/go-crypto-winnative v0.0.0-20230502061212-6eb98854418e/go.mod h1:fveERXKbeK+XLmOyU24caKnIT/S5nniAX9XCRHfnrM4=
 golang.org/x/crypto v0.9.0 h1:LF6fAI+IutBocDJ2OT0Q1g8plpYljMZ4+lty+dsqw3g=
 golang.org/x/crypto v0.9.0/go.mod h1:yrmDGqONDYtNj3tH8X9dzUun2m2lzPa9ngI6/RUPGR0=
 golang.org/x/net v0.10.1-0.20230525180353-f7250ea19d21 h1:jUMNhNY++lQOGP3xpA6+oKyHzRWdM7e6XBFppuDXEUw=
diff --git a/src/go/build/deps_test.go b/src/go/build/deps_test.go
index e6127a33d00ccc..a70685200fb0a7 100644
--- a/src/go/build/deps_test.go
+++ b/src/go/build/deps_test.go
@@ -425,6 +425,10 @@ var depsRules = `
 
 	crypto/cipher,
 	crypto/internal/boring/bcache
+	< github.com/microsoft/go-crypto-winnative/internal/subtle
+	< github.com/microsoft/go-crypto-winnative/internal/sysdll
+	< github.com/microsoft/go-crypto-winnative/internal/bcrypt
+	< github.com/microsoft/go-crypto-winnative/cng
 	< github.com/golang-fips/openssl/internal/subtle
 	< github.com/golang-fips/openssl
 	< crypto/internal/boring
@@ -461,6 +465,7 @@ var depsRules = `
 
 	# CRYPTO-MATH is core bignum-based crypto - no cgo, net; fmt now ok.
 	CRYPTO, FMT, math/big
+	< github.com/microsoft/go-crypto-winnative/cng/bbig
 	< github.com/golang-fips/openssl/bbig
 	< crypto/internal/boring/bbig
 	< crypto/internal/backend/bbig
diff --git a/src/hash/example_test.go b/src/hash/example_test.go
index f07b9aaa2c4898..2ff6c4827391c0 100644
--- a/src/hash/example_test.go
+++ b/src/hash/example_test.go
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
+//go:build !goexperiment.cngcrypto
+
 package hash_test
 
 import (
diff --git a/src/hash/marshal_test.go b/src/hash/marshal_test.go
index 3091f7a67acede..824be4a90fd4db 100644
--- a/src/hash/marshal_test.go
+++ b/src/hash/marshal_test.go
@@ -21,6 +21,7 @@ import (
 	"hash/crc32"
 	"hash/crc64"
 	"hash/fnv"
+	"internal/goexperiment"
 	"testing"
 )
 
@@ -76,6 +77,9 @@ func TestMarshalHash(t *testing.T) {
 			}
 			h2m, ok := h2.(encoding.BinaryMarshaler)
 			if !ok {
+				if goexperiment.CNGCrypto {
+					t.Skip("CNGCrypto does not hash marshaling")
+				}
 				t.Fatalf("Hash does not implement MarshalBinary")
 			}
 			enc, err := h2m.MarshalBinary()
diff --git a/src/internal/goexperiment/exp_cngcrypto_off.go b/src/internal/goexperiment/exp_cngcrypto_off.go
new file mode 100644
index 00000000000000..831460053281e2
--- /dev/null
+++ b/src/internal/goexperiment/exp_cngcrypto_off.go
@@ -0,0 +1,9 @@
+// Code generated by mkconsts.go. DO NOT EDIT.
+
+//go:build !goexperiment.cngcrypto
+// +build !goexperiment.cngcrypto
+
+package goexperiment
+
+const CNGCrypto = false
+const CNGCryptoInt = 0
diff --git a/src/internal/goexperiment/exp_cngcrypto_on.go b/src/internal/goexperiment/exp_cngcrypto_on.go
new file mode 100644
index 00000000000000..99ee2542ca38a9
--- /dev/null
+++ b/src/internal/goexperiment/exp_cngcrypto_on.go
@@ -0,0 +1,9 @@
+// Code generated by mkconsts.go. DO NOT EDIT.
+
+//go:build goexperiment.cngcrypto
+// +build goexperiment.cngcrypto
+
+package goexperiment
+
+const CNGCrypto = true
+const CNGCryptoInt = 1
diff --git a/src/internal/goexperiment/flags.go b/src/internal/goexperiment/flags.go
index c808c5e3b3675e..48deab0d2b1cf9 100644
--- a/src/internal/goexperiment/flags.go
+++ b/src/internal/goexperiment/flags.go
@@ -60,6 +60,7 @@ type Flags struct {
 	StaticLockRanking bool
 	BoringCrypto      bool
 	OpenSSLCrypto     bool
+	CNGCrypto         bool
 
 	// Regabi is split into several sub-experiments that can be
 	// enabled individually. Not all combinations work.

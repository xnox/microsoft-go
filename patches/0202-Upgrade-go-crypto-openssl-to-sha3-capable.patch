From 4c50bd765f76109882d8cc42dc2540da1f9e61d9 Mon Sep 17 00:00:00 2001
From: Dimitri John Ledkov <dimitri.ledkov@canonical.com>
Date: Sun, 2 Jul 2023 00:44:15 +0100
Subject: [PATCH 202/204] Upgrade go-crypto-openssl to sha3 capable

Signed-off-by: Dimitri John Ledkov <dimitri.ledkov@canonical.com>
---
 src/crypto/internal/backend/openssl_linux.go  |  17 +-
 src/go.mod                                    |   4 +-
 src/go.sum                                    |   4 +-
 .../go-crypto-openssl/openssl/aes.go          |  12 +-
 .../go-crypto-openssl/openssl/bbig/big.go     |  38 +++
 .../openssl/bbig/bridge/bridge.go             |  83 +++++++
 .../go-crypto-openssl/openssl/big.go          |  13 +
 .../go-crypto-openssl/openssl/ecdh.go         | 223 ++++++++++++++++++
 .../go-crypto-openssl/openssl/ecdsa.go        |  92 ++------
 .../go-crypto-openssl/openssl/evpkey.go       | 157 ++++++++----
 .../go-crypto-openssl/openssl/goopenssl.c     |  53 ++++-
 .../go-crypto-openssl/openssl/goopenssl.h     |  23 +-
 .../go-crypto-openssl/openssl/hmac.go         | 150 ++++++++++--
 .../go-crypto-openssl/openssl/openssl.go      | 149 ++++++++----
 .../go-crypto-openssl/openssl/openssl_funcs.h |  70 +++++-
 .../go-crypto-openssl/openssl/rsa.go          |  82 +++++--
 .../go-crypto-openssl/openssl/sha.go          | 191 ++++++++++++++-
 src/vendor/modules.txt                        |   6 +-
 18 files changed, 1125 insertions(+), 242 deletions(-)
 create mode 100644 src/vendor/github.com/microsoft/go-crypto-openssl/openssl/bbig/big.go
 create mode 100644 src/vendor/github.com/microsoft/go-crypto-openssl/openssl/bbig/bridge/bridge.go
 create mode 100644 src/vendor/github.com/microsoft/go-crypto-openssl/openssl/big.go
 create mode 100644 src/vendor/github.com/microsoft/go-crypto-openssl/openssl/ecdh.go

diff --git a/src/crypto/internal/backend/openssl_linux.go b/src/crypto/internal/backend/openssl_linux.go
index 659104006e..6678020bf1 100644
--- a/src/crypto/internal/backend/openssl_linux.go
+++ b/src/crypto/internal/backend/openssl_linux.go
@@ -15,6 +15,7 @@ import (
 	"syscall"
 
 	"github.com/microsoft/go-crypto-openssl/openssl"
+	"github.com/microsoft/go-crypto-openssl/openssl/bbig/bridge"
 )
 
 // Enabled controls whether FIPS crypto is enabled.
@@ -116,12 +117,12 @@ var NewAESCipher = openssl.NewAESCipher
 type PublicKeyECDSA = openssl.PublicKeyECDSA
 type PrivateKeyECDSA = openssl.PrivateKeyECDSA
 
-var GenerateKeyECDSA = openssl.GenerateKeyECDSA
-var NewPrivateKeyECDSA = openssl.NewPrivateKeyECDSA
-var NewPublicKeyECDSA = openssl.NewPublicKeyECDSA
-var SignECDSA = openssl.SignECDSA
+var GenerateKeyECDSA = bridge.GenerateKeyECDSA
+var NewPrivateKeyECDSA = bridge.NewPrivateKeyECDSA
+var NewPublicKeyECDSA = bridge.NewPublicKeyECDSA
+var SignECDSA = bridge.SignECDSA
 var SignMarshalECDSA = openssl.SignMarshalECDSA
-var VerifyECDSA = openssl.VerifyECDSA
+var VerifyECDSA = bridge.VerifyECDSA
 
 type PublicKeyRSA = openssl.PublicKeyRSA
 type PrivateKeyRSA = openssl.PrivateKeyRSA
@@ -132,9 +133,9 @@ var DecryptRSANoPadding = openssl.DecryptRSANoPadding
 var EncryptRSAOAEP = openssl.EncryptRSAOAEP
 var EncryptRSAPKCS1 = openssl.EncryptRSAPKCS1
 var EncryptRSANoPadding = openssl.EncryptRSANoPadding
-var GenerateKeyRSA = openssl.GenerateKeyRSA
-var NewPrivateKeyRSA = openssl.NewPrivateKeyRSA
-var NewPublicKeyRSA = openssl.NewPublicKeyRSA
+var GenerateKeyRSA = bridge.GenerateKeyRSA
+var NewPrivateKeyRSA = bridge.NewPrivateKeyRSA
+var NewPublicKeyRSA = bridge.NewPublicKeyRSA
 var SignRSAPKCS1v15 = openssl.SignRSAPKCS1v15
 var SignRSAPSS = openssl.SignRSAPSS
 var VerifyRSAPKCS1v15 = openssl.VerifyRSAPKCS1v15
diff --git a/src/go.mod b/src/go.mod
index 5a46c4c944..1d46c8fa5d 100644
--- a/src/go.mod
+++ b/src/go.mod
@@ -3,7 +3,7 @@ module std
 go 1.18
 
 require (
-	github.com/microsoft/go-crypto-openssl v0.1.2
+	github.com/microsoft/go-crypto-openssl v0.2.8
 	golang.org/x/crypto v0.0.0-20211215153901-e495a2d5b3d3
 	golang.org/x/net v0.0.0-20221214163811-6143a133e5c9
 )
@@ -12,3 +12,5 @@ require (
 	golang.org/x/sys v0.0.0-20220310020820-b874c991c1a5 // indirect
 	golang.org/x/text v0.3.8-0.20211105212822-18b340fc7af2 // indirect
 )
+
+replace github.com/microsoft/go-crypto-openssl v0.2.8 => github.com/xnox/go-crypto-openssl v0.2.9-0.20230701230530-84b71a4b45db
diff --git a/src/go.sum b/src/go.sum
index 46ee4c4442..1ebb25d4ef 100644
--- a/src/go.sum
+++ b/src/go.sum
@@ -1,5 +1,5 @@
-github.com/microsoft/go-crypto-openssl v0.1.2 h1:1JO/O62aLFCGpKWKrxdxzIITNJJ00hkBL0v/LLpEZUM=
-github.com/microsoft/go-crypto-openssl v0.1.2/go.mod h1:rC+rtBU3m60UCQifBmpWII0VETfu78w6YGZQvVc0rd4=
+github.com/xnox/go-crypto-openssl v0.2.9-0.20230701230530-84b71a4b45db h1:wDf6GGeSKkHOjTTNV5jky1+zXm9U4qoDW7kGtKk726A=
+github.com/xnox/go-crypto-openssl v0.2.9-0.20230701230530-84b71a4b45db/go.mod h1:xOSmQnWz4xvNB2+KQN2g2UUwMG9vqDHBk9nk/NdmyRw=
 golang.org/x/crypto v0.0.0-20211215153901-e495a2d5b3d3 h1:0es+/5331RGQPcXlMfP+WrnIIS6dNnNRe0WB02W0F4M=
 golang.org/x/crypto v0.0.0-20211215153901-e495a2d5b3d3/go.mod h1:IxCIyHEi3zRg3s0A5j5BB6A9Jmi73HwBIUl50j+osU4=
 golang.org/x/net v0.0.0-20221214163811-6143a133e5c9 h1:gcbGP3ZkgsHGpX/48qvg7Q/YmTtzZRWc/zpvN8XGSBg=
diff --git a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/aes.go b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/aes.go
index 3177c0d37c..46d70bf264 100644
--- a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/aes.go
+++ b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/aes.go
@@ -116,8 +116,12 @@ func (c *aesCipher) Decrypt(dst, src []byte) {
 		if err != nil {
 			panic(err)
 		}
+		// Disable standard block padding detection,
+		// src is always multiple of the block size.
+		if C.go_openssl_EVP_CIPHER_CTX_set_padding(c.dec_ctx, 0) != 1 {
+			panic("crypto/cipher: unable to set padding")
+		}
 	}
-
 	C.go_openssl_EVP_DecryptUpdate_wrapper(c.dec_ctx, base(dst), base(src), aesBlockSize)
 	runtime.KeepAlive(c)
 }
@@ -296,6 +300,12 @@ func (c *aesCipher) NewGCM(nonceSize, tagSize int) (cipher.AEAD, error) {
 	return c.newGCM(false)
 }
 
+// NewGCMTLS returns a GCM cipher specific to TLS
+// and should not be used for non-TLS purposes.
+func NewGCMTLS(c cipher.Block) (cipher.AEAD, error) {
+	return c.(*aesCipher).NewGCMTLS()
+}
+
 func (c *aesCipher) NewGCMTLS() (cipher.AEAD, error) {
 	return c.newGCM(true)
 }
diff --git a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/bbig/big.go b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/bbig/big.go
new file mode 100644
index 0000000000..1214e1097e
--- /dev/null
+++ b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/bbig/big.go
@@ -0,0 +1,38 @@
+// Copyright 2022 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// This is a mirror of crypto/internal/boring/bbig/big.go.
+
+package bbig
+
+import (
+	"math/big"
+	"unsafe"
+
+	"github.com/microsoft/go-crypto-openssl/openssl"
+)
+
+func Enc(b *big.Int) openssl.BigInt {
+	if b == nil {
+		return nil
+	}
+	x := b.Bits()
+	if len(x) == 0 {
+		return openssl.BigInt{}
+	}
+	// TODO: Use unsafe.Slice((*uint)(&x[0]), len(x)) once go1.16 is no longer supported.
+	return (*(*[]uint)(unsafe.Pointer(&x)))[:len(x)]
+}
+
+func Dec(b openssl.BigInt) *big.Int {
+	if b == nil {
+		return nil
+	}
+	if len(b) == 0 {
+		return new(big.Int)
+	}
+	// TODO: Use unsafe.Slice((*uint)(&b[0]), len(b)) once go1.16 is no longer supported.
+	x := (*(*[]big.Word)(unsafe.Pointer(&b)))[:len(b)]
+	return new(big.Int).SetBits(x)
+}
diff --git a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/bbig/bridge/bridge.go b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/bbig/bridge/bridge.go
new file mode 100644
index 0000000000..43f5e60049
--- /dev/null
+++ b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/bbig/bridge/bridge.go
@@ -0,0 +1,83 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+// These wrappers only exist for code reuse in places where we need the old pre-go1.19 signature.
+
+package bridge
+
+import (
+	"encoding/asn1"
+	"math/big"
+
+	"github.com/microsoft/go-crypto-openssl/openssl"
+	"github.com/microsoft/go-crypto-openssl/openssl/bbig"
+)
+
+func GenerateKeyECDSA(curve string) (X, Y, D *big.Int, err error) {
+	x, y, d, err := openssl.GenerateKeyECDSA(curve)
+	if err != nil {
+		return nil, nil, nil, err
+	}
+	return bbig.Dec(x), bbig.Dec(y), bbig.Dec(d), nil
+}
+
+type ecdsaSignature struct {
+	R, S *big.Int
+}
+
+func SignECDSA(priv *openssl.PrivateKeyECDSA, hash []byte) (r, s *big.Int, err error) {
+	sig, err := openssl.SignMarshalECDSA(priv, hash)
+	if err != nil {
+		return nil, nil, err
+	}
+	var esig ecdsaSignature
+	if _, err := asn1.Unmarshal(sig, &esig); err != nil {
+		return nil, nil, err
+	}
+	return esig.R, esig.S, nil
+}
+
+func NewPrivateKeyECDSA(curve string, X, Y, D *big.Int) (*openssl.PrivateKeyECDSA, error) {
+	return openssl.NewPrivateKeyECDSA(curve, bbig.Enc(X), bbig.Enc(Y), bbig.Enc(D))
+}
+
+func NewPublicKeyECDSA(curve string, X, Y *big.Int) (*openssl.PublicKeyECDSA, error) {
+	return openssl.NewPublicKeyECDSA(curve, bbig.Enc(X), bbig.Enc(Y))
+}
+
+func VerifyECDSA(pub *openssl.PublicKeyECDSA, hash []byte, r, s *big.Int) bool {
+	sig, err := asn1.Marshal(ecdsaSignature{r, s})
+	if err != nil {
+		return false
+	}
+	return openssl.VerifyECDSA(pub, hash, sig)
+}
+
+func GenerateKeyRSA(bits int) (N, E, D, P, Q, Dp, Dq, Qinv *big.Int, err error) {
+	bN, bE, bD, bP, bQ, bDp, bDq, bQinv, err1 := openssl.GenerateKeyRSA(bits)
+	if err1 != nil {
+		err = err1
+		return
+	}
+	N = bbig.Dec(bN)
+	E = bbig.Dec(bE)
+	D = bbig.Dec(bD)
+	P = bbig.Dec(bP)
+	Q = bbig.Dec(bQ)
+	Dp = bbig.Dec(bDp)
+	Dq = bbig.Dec(bDq)
+	Qinv = bbig.Dec(bQinv)
+	return
+}
+
+func NewPublicKeyRSA(N, E *big.Int) (*openssl.PublicKeyRSA, error) {
+	return openssl.NewPublicKeyRSA(bbig.Enc(N), bbig.Enc(E))
+}
+
+func NewPrivateKeyRSA(N, E, D, P, Q, Dp, Dq, Qinv *big.Int) (*openssl.PrivateKeyRSA, error) {
+	return openssl.NewPrivateKeyRSA(
+		bbig.Enc(N), bbig.Enc(E), bbig.Enc(D),
+		bbig.Enc(P), bbig.Enc(Q),
+		bbig.Enc(Dp), bbig.Enc(Dq), bbig.Enc(Qinv),
+	)
+}
diff --git a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/big.go b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/big.go
new file mode 100644
index 0000000000..c6856c7bc2
--- /dev/null
+++ b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/big.go
@@ -0,0 +1,13 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+package openssl
+
+// This file does not have build constraints to
+// facilitate using BigInt in Go crypto.
+// Go crypto references BigInt unconditionally,
+// even if it is not finally used.
+
+// A BigInt is the raw words from a BigInt.
+// This definition allows us to avoid importing math/big.
+// Conversion between BigInt and *big.Int is in openssl/bbig.
+type BigInt []uint
diff --git a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/ecdh.go b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/ecdh.go
new file mode 100644
index 0000000000..fba3704531
--- /dev/null
+++ b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/ecdh.go
@@ -0,0 +1,223 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+//go:build linux && !android
+// +build linux,!android
+
+package openssl
+
+// #include "goopenssl.h"
+import "C"
+import (
+	"errors"
+	"runtime"
+)
+
+type PublicKeyECDH struct {
+	_pkey C.GO_EVP_PKEY_PTR
+	bytes []byte
+
+	// priv is only set when PublicKeyECDH is derived from a private key,
+	// in which case priv's finalizer is responsible for freeing _pkey.
+	// This ensures priv is not finalized while the public key is alive,
+	// which could cause use-after-free and double-free behavior.
+	//
+	// We could avoid this altogether if using EVP_PKEY_up_ref
+	// when instantiating a derived public key, unfortunately
+	// it is not available on OpenSSL 1.0.2.
+	priv *PrivateKeyECDH
+}
+
+func (k *PublicKeyECDH) finalize() {
+	if k.priv == nil {
+		C.go_openssl_EVP_PKEY_free(k._pkey)
+	}
+}
+
+type PrivateKeyECDH struct {
+	_pkey C.GO_EVP_PKEY_PTR
+}
+
+func (k *PrivateKeyECDH) finalize() {
+	C.go_openssl_EVP_PKEY_free(k._pkey)
+}
+
+func NewPublicKeyECDH(curve string, bytes []byte) (*PublicKeyECDH, error) {
+	if len(bytes) < 1 {
+		return nil, errors.New("NewPublicKeyECDH: missing key")
+	}
+	nid, err := curveNID(curve)
+	if err != nil {
+		return nil, err
+	}
+	key := C.go_openssl_EC_KEY_new_by_curve_name(nid)
+	if key == nil {
+		return nil, newOpenSSLError("EC_KEY_new_by_curve_name")
+	}
+	var k *PublicKeyECDH
+	defer func() {
+		if k == nil {
+			C.go_openssl_EC_KEY_free(key)
+		}
+	}()
+	if vMajor == 1 && vMinor == 0 {
+		// EC_KEY_oct2key does not exist on OpenSSL 1.0.2,
+		// we have to simulate it.
+		group := C.go_openssl_EC_KEY_get0_group(key)
+		pt := C.go_openssl_EC_POINT_new(group)
+		if pt == nil {
+			return nil, newOpenSSLError("EC_POINT_new")
+		}
+		defer C.go_openssl_EC_POINT_free(pt)
+		if C.go_openssl_EC_POINT_oct2point(group, pt, base(bytes), C.size_t(len(bytes)), nil) != 1 {
+			return nil, errors.New("point not on curve")
+		}
+		if C.go_openssl_EC_KEY_set_public_key(key, pt) != 1 {
+			return nil, newOpenSSLError("EC_KEY_set_public_key")
+		}
+	} else {
+		if C.go_openssl_EC_KEY_oct2key(key, base(bytes), C.size_t(len(bytes)), nil) != 1 {
+			return nil, newOpenSSLError("EC_KEY_oct2key")
+		}
+	}
+	pkey, err := newEVPPKEY(key)
+	if err != nil {
+		return nil, err
+	}
+	k = &PublicKeyECDH{pkey, append([]byte(nil), bytes...), nil}
+	runtime.SetFinalizer(k, (*PublicKeyECDH).finalize)
+	return k, nil
+}
+
+func (k *PublicKeyECDH) Bytes() []byte { return k.bytes }
+
+func NewPrivateKeyECDH(curve string, bytes []byte) (*PrivateKeyECDH, error) {
+	nid, err := curveNID(curve)
+	if err != nil {
+		return nil, err
+	}
+	b := bytesToBN(bytes)
+	if b == nil {
+		return nil, newOpenSSLError("BN_bin2bn")
+	}
+	defer C.go_openssl_BN_free(b)
+	key := C.go_openssl_EC_KEY_new_by_curve_name(nid)
+	if key == nil {
+		return nil, newOpenSSLError("EC_KEY_new_by_curve_name")
+	}
+	var pkey C.GO_EVP_PKEY_PTR
+	defer func() {
+		if pkey == nil {
+			C.go_openssl_EC_KEY_free(key)
+		}
+	}()
+	if C.go_openssl_EC_KEY_set_private_key(key, b) != 1 {
+		return nil, newOpenSSLError("EC_KEY_set_private_key")
+	}
+	pkey, err = newEVPPKEY(key)
+	if err != nil {
+		return nil, err
+	}
+	k := &PrivateKeyECDH{pkey}
+	runtime.SetFinalizer(k, (*PrivateKeyECDH).finalize)
+	return k, nil
+}
+
+func (k *PrivateKeyECDH) PublicKey() (*PublicKeyECDH, error) {
+	defer runtime.KeepAlive(k)
+	key := C.go_openssl_EVP_PKEY_get1_EC_KEY(k._pkey)
+	if key == nil {
+		return nil, newOpenSSLError("EVP_PKEY_get1_EC_KEY")
+	}
+	defer C.go_openssl_EC_KEY_free(key)
+	group := C.go_openssl_EC_KEY_get0_group(key)
+	if group == nil {
+		return nil, newOpenSSLError("EC_KEY_get0_group")
+	}
+	pt := C.go_openssl_EC_KEY_get0_public_key(key)
+	if pt == nil {
+		// The public key will be nil if k has been generated using
+		// NewPrivateKeyECDH instead of GenerateKeyECDH.
+		//
+		// OpenSSL does not expose any method to generate the public
+		// key from the private key [1], so we have to calculate it here
+		// https://github.com/openssl/openssl/issues/18437#issuecomment-1144717206
+		pt = C.go_openssl_EC_POINT_new(group)
+		if pt == nil {
+			return nil, newOpenSSLError("EC_POINT_new")
+		}
+		defer C.go_openssl_EC_POINT_free(pt)
+		kbig := C.go_openssl_EC_KEY_get0_private_key(key)
+		if C.go_openssl_EC_POINT_mul(group, pt, kbig, nil, nil, nil) == 0 {
+			return nil, newOpenSSLError("EC_POINT_mul")
+		}
+	}
+	n := C.go_openssl_EC_POINT_point2oct(group, pt, C.GO_POINT_CONVERSION_UNCOMPRESSED, nil, 0, nil)
+	if n == 0 {
+		return nil, newOpenSSLError("EC_POINT_point2oct")
+	}
+	bytes := make([]byte, n)
+	n = C.go_openssl_EC_POINT_point2oct(group, pt, C.GO_POINT_CONVERSION_UNCOMPRESSED, base(bytes), C.size_t(len(bytes)), nil)
+	if int(n) != len(bytes) {
+		return nil, newOpenSSLError("EC_POINT_point2oct")
+	}
+	pub := &PublicKeyECDH{k._pkey, bytes, k}
+	// Note: Same as in NewPublicKeyECDH regarding finalizer and KeepAlive.
+	runtime.SetFinalizer(pub, (*PublicKeyECDH).finalize)
+	return pub, nil
+}
+
+func ECDH(priv *PrivateKeyECDH, pub *PublicKeyECDH) ([]byte, error) {
+	defer runtime.KeepAlive(priv)
+	defer runtime.KeepAlive(pub)
+	ctx := C.go_openssl_EVP_PKEY_CTX_new(priv._pkey, nil)
+	if ctx == nil {
+		return nil, newOpenSSLError("EVP_PKEY_CTX_new")
+	}
+	defer C.go_openssl_EVP_PKEY_CTX_free(ctx)
+	if C.go_openssl_EVP_PKEY_derive_init(ctx) != 1 {
+		return nil, newOpenSSLError("EVP_PKEY_derive_init")
+	}
+	if C.go_openssl_EVP_PKEY_derive_set_peer(ctx, pub._pkey) != 1 {
+		return nil, newOpenSSLError("EVP_PKEY_derive_set_peer")
+	}
+	var outLen C.size_t
+	if C.go_openssl_EVP_PKEY_derive(ctx, nil, &outLen) != 1 {
+		return nil, newOpenSSLError("EVP_PKEY_derive_init")
+	}
+	out := make([]byte, outLen)
+	if C.go_openssl_EVP_PKEY_derive(ctx, base(out), &outLen) != 1 {
+		return nil, newOpenSSLError("EVP_PKEY_derive_init")
+	}
+	return out, nil
+}
+
+func GenerateKeyECDH(curve string) (*PrivateKeyECDH, []byte, error) {
+	pkey, err := generateEVPPKey(C.GO_EVP_PKEY_EC, 0, curve)
+	if err != nil {
+		return nil, nil, err
+	}
+	var k *PrivateKeyECDH
+	defer func() {
+		if k == nil {
+			C.go_openssl_EVP_PKEY_free(pkey)
+		}
+	}()
+	key := C.go_openssl_EVP_PKEY_get1_EC_KEY(pkey)
+	if key == nil {
+		return nil, nil, newOpenSSLError("EVP_PKEY_get1_EC_KEY")
+	}
+	defer C.go_openssl_EC_KEY_free(key)
+	b := C.go_openssl_EC_KEY_get0_private_key(key)
+	if b == nil {
+		return nil, nil, newOpenSSLError("EC_KEY_get0_private_key")
+	}
+	bits := C.go_openssl_EVP_PKEY_get_bits(pkey)
+	out := make([]byte, (bits+7)/8)
+	if C.go_openssl_BN_bn2binpad(b, base(out), C.int(len(out))) == 0 {
+		return nil, nil, newOpenSSLError("BN_bn2binpad")
+	}
+	k = &PrivateKeyECDH{pkey}
+	runtime.SetFinalizer(k, (*PrivateKeyECDH).finalize)
+	return k, out, nil
+}
diff --git a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/ecdsa.go b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/ecdsa.go
index 84f82e903c..de4aa0ecfc 100644
--- a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/ecdsa.go
+++ b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/ecdsa.go
@@ -9,17 +9,10 @@ package openssl
 // #include "goopenssl.h"
 import "C"
 import (
-	"encoding/asn1"
 	"errors"
-	"math/big"
 	"runtime"
-	"unsafe"
 )
 
-type ecdsaSignature struct {
-	R, S *big.Int
-}
-
 type PrivateKeyECDSA struct {
 	// _pkey MUST NOT be accessed directly. Instead, use the withKey method.
 	_pkey C.GO_EVP_PKEY_PTR
@@ -65,7 +58,7 @@ func curveNID(curve string) (C.int, error) {
 	return 0, errUnknownCurve
 }
 
-func NewPublicKeyECDSA(curve string, X, Y *big.Int) (*PublicKeyECDSA, error) {
+func NewPublicKeyECDSA(curve string, X, Y BigInt) (*PublicKeyECDSA, error) {
 	pkey, err := newECKey(curve, X, Y, nil)
 	if err != nil {
 		return nil, err
@@ -79,13 +72,12 @@ func NewPublicKeyECDSA(curve string, X, Y *big.Int) (*PublicKeyECDSA, error) {
 	return k, nil
 }
 
-func newECKey(curve string, X, Y, D *big.Int) (pkey C.GO_EVP_PKEY_PTR, err error) {
-	var nid C.int
-	if nid, err = curveNID(curve); err != nil {
+func newECKey(curve string, X, Y, D BigInt) (C.GO_EVP_PKEY_PTR, error) {
+	nid, err := curveNID(curve)
+	if err != nil {
 		return nil, err
 	}
-	var bx, by C.GO_BIGNUM_PTR
-	var key C.GO_EC_KEY_PTR
+	var bx, by, bd C.GO_BIGNUM_PTR
 	defer func() {
 		if bx != nil {
 			C.go_openssl_BN_free(bx)
@@ -93,49 +85,40 @@ func newECKey(curve string, X, Y, D *big.Int) (pkey C.GO_EVP_PKEY_PTR, err error
 		if by != nil {
 			C.go_openssl_BN_free(by)
 		}
-		if err != nil {
-			if key != nil {
-				C.go_openssl_EC_KEY_free(key)
-			}
-			if pkey != nil {
-				C.go_openssl_EVP_PKEY_free(pkey)
-				// pkey is a named return, so in case of error
-				// it have to be cleared before returing.
-				pkey = nil
-			}
+		if bd != nil {
+			C.go_openssl_BN_free(bd)
 		}
 	}()
 	bx = bigToBN(X)
 	by = bigToBN(Y)
-	if bx == nil || by == nil {
-		return nil, newOpenSSLError("BN_bin2bn failed")
+	bd = bigToBN(D)
+	if bx == nil || by == nil || (D != nil && bd == nil) {
+		return nil, newOpenSSLError("BN_lebin2bn failed")
 	}
-	if key = C.go_openssl_EC_KEY_new_by_curve_name(nid); key == nil {
+	key := C.go_openssl_EC_KEY_new_by_curve_name(nid)
+	if key == nil {
 		return nil, newOpenSSLError("EC_KEY_new_by_curve_name failed")
 	}
+	var pkey C.GO_EVP_PKEY_PTR
+	defer func() {
+		if pkey == nil {
+			defer C.go_openssl_EC_KEY_free(key)
+		}
+	}()
 	if C.go_openssl_EC_KEY_set_public_key_affine_coordinates(key, bx, by) != 1 {
 		return nil, newOpenSSLError("EC_KEY_set_public_key_affine_coordinates failed")
 	}
-	if D != nil {
-		bd := bigToBN(D)
-		if bd == nil {
-			return nil, newOpenSSLError("BN_bin2bn failed")
-		}
-		defer C.go_openssl_BN_free(bd)
-		if C.go_openssl_EC_KEY_set_private_key(key, bd) != 1 {
-			return nil, newOpenSSLError("EC_KEY_set_private_key failed")
-		}
-	}
-	if pkey = C.go_openssl_EVP_PKEY_new(); pkey == nil {
-		return nil, newOpenSSLError("EVP_PKEY_new failed")
+	if D != nil && C.go_openssl_EC_KEY_set_private_key(key, bd) != 1 {
+		return nil, newOpenSSLError("EC_KEY_set_private_key failed")
 	}
-	if C.go_openssl_EVP_PKEY_assign(pkey, C.GO_EVP_PKEY_EC, (unsafe.Pointer)(key)) != 1 {
-		return nil, newOpenSSLError("EVP_PKEY_assign failed")
+	pkey, err = newEVPPKEY(key)
+	if err != nil {
+		return nil, err
 	}
 	return pkey, nil
 }
 
-func NewPrivateKeyECDSA(curve string, X, Y *big.Int, D *big.Int) (*PrivateKeyECDSA, error) {
+func NewPrivateKeyECDSA(curve string, X, Y, D BigInt) (*PrivateKeyECDSA, error) {
 	pkey, err := newECKey(curve, X, Y, D)
 	if err != nil {
 		return nil, err
@@ -149,38 +132,15 @@ func NewPrivateKeyECDSA(curve string, X, Y *big.Int, D *big.Int) (*PrivateKeyECD
 	return k, nil
 }
 
-func SignECDSA(priv *PrivateKeyECDSA, hash []byte) (r, s *big.Int, err error) {
-	// We could use ECDSA_do_sign instead but would need to convert
-	// the resulting BIGNUMs to *big.Int form. If we're going to do a
-	// conversion, converting the ASN.1 form is more convenient and
-	// likely not much more expensive.
-	sig, err := SignMarshalECDSA(priv, hash)
-	if err != nil {
-		return nil, nil, err
-	}
-	var esig ecdsaSignature
-	if _, err := asn1.Unmarshal(sig, &esig); err != nil {
-		return nil, nil, err
-	}
-	return esig.R, esig.S, nil
-}
-
 func SignMarshalECDSA(priv *PrivateKeyECDSA, hash []byte) ([]byte, error) {
 	return evpSign(priv.withKey, 0, 0, 0, hash)
 }
 
-func VerifyECDSA(pub *PublicKeyECDSA, hash []byte, r, s *big.Int) bool {
-	// We could use ECDSA_do_verify instead but would need to convert
-	// r and s to BIGNUM form. If we're going to do a conversion, marshaling
-	// to ASN.1 is more convenient and likely not much more expensive.
-	sig, err := asn1.Marshal(ecdsaSignature{r, s})
-	if err != nil {
-		return false
-	}
+func VerifyECDSA(pub *PublicKeyECDSA, hash []byte, sig []byte) bool {
 	return evpVerify(pub.withKey, 0, 0, 0, sig, hash) == nil
 }
 
-func GenerateKeyECDSA(curve string) (X, Y, D *big.Int, err error) {
+func GenerateKeyECDSA(curve string) (X, Y, D BigInt, err error) {
 	pkey, err := generateEVPPKey(C.GO_EVP_PKEY_EC, 0, curve)
 	if err != nil {
 		return nil, nil, nil, err
diff --git a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/evpkey.go b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/evpkey.go
index 03a652aef1..638f0e134d 100644
--- a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/evpkey.go
+++ b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/evpkey.go
@@ -57,6 +57,26 @@ func cryptoHashToMD(ch crypto.Hash) C.GO_EVP_MD_PTR {
 		return C.go_openssl_EVP_sha384()
 	case crypto.SHA512:
 		return C.go_openssl_EVP_sha512()
+	case crypto.SHA3_224:
+		if !SupportsSHA3() {
+			return nil
+		}
+		return C.go_openssl_EVP_sha3_224()
+	case crypto.SHA3_256:
+		if !SupportsSHA3() {
+			return nil
+		}
+		return C.go_openssl_EVP_sha3_256()
+	case crypto.SHA3_384:
+		if !SupportsSHA3() {
+			return nil
+		}
+		return C.go_openssl_EVP_sha3_384()
+	case crypto.SHA3_512:
+		if !SupportsSHA3() {
+			return nil
+		}
+		return C.go_openssl_EVP_sha3_512()
 	}
 	return nil
 }
@@ -95,12 +115,12 @@ func generateEVPPKey(id C.int, bits int, curve string) (C.GO_EVP_PKEY_PTR, error
 }
 
 type withKeyFunc func(func(C.GO_EVP_PKEY_PTR) C.int) C.int
-type initFunc func(C.GO_EVP_PKEY_CTX_PTR) C.int
-type cryptFunc func(C.GO_EVP_PKEY_CTX_PTR, *C.uchar, *C.size_t, *C.uchar, C.size_t) C.int
-type verifyFunc func(C.GO_EVP_PKEY_CTX_PTR, *C.uchar, C.size_t, *C.uchar, C.size_t) C.int
+type initFunc func(C.GO_EVP_PKEY_CTX_PTR) error
+type cryptFunc func(C.GO_EVP_PKEY_CTX_PTR, *C.uchar, *C.size_t, *C.uchar, C.size_t) error
+type verifyFunc func(C.GO_EVP_PKEY_CTX_PTR, *C.uchar, C.size_t, *C.uchar, C.size_t) error
 
 func setupEVP(withKey withKeyFunc, padding C.int,
-	h hash.Hash, label []byte, saltLen int, ch crypto.Hash,
+	h, mgfHash hash.Hash, label []byte, saltLen C.int, ch crypto.Hash,
 	init initFunc) (ctx C.GO_EVP_PKEY_CTX_PTR, err error) {
 	defer func() {
 		if err != nil {
@@ -118,8 +138,8 @@ func setupEVP(withKey withKeyFunc, padding C.int,
 	if ctx == nil {
 		return nil, newOpenSSLError("EVP_PKEY_CTX_new failed")
 	}
-	if init(ctx) != 1 {
-		return nil, newOpenSSLError("EVP_PKEY_operation_init failed")
+	if err := init(ctx); err != nil {
+		return nil, err
 	}
 	if padding == 0 {
 		return ctx, nil
@@ -138,6 +158,14 @@ func setupEVP(withKey withKeyFunc, padding C.int,
 		if md == nil {
 			return nil, errors.New("crypto/rsa: unsupported hash function")
 		}
+		var mgfMD C.GO_EVP_MD_PTR
+		if mgfHash != nil {
+			// mgfHash is optional, but if it is set it must match a supported hash function.
+			mgfMD = hashToMD(mgfHash)
+			if mgfMD == nil {
+				return nil, errors.New("crypto/rsa: unsupported hash function")
+			}
+		}
 		// setPadding must happen before setting EVP_PKEY_CTRL_RSA_OAEP_MD.
 		if err := setPadding(); err != nil {
 			return nil, err
@@ -145,6 +173,11 @@ func setupEVP(withKey withKeyFunc, padding C.int,
 		if C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, C.GO_EVP_PKEY_RSA, -1, C.GO_EVP_PKEY_CTRL_RSA_OAEP_MD, 0, unsafe.Pointer(md)) != 1 {
 			return nil, newOpenSSLError("EVP_PKEY_CTX_ctrl failed")
 		}
+		if mgfHash != nil {
+			if C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, C.GO_EVP_PKEY_RSA, -1, C.GO_EVP_PKEY_CTRL_RSA_MGF1_MD, 0, unsafe.Pointer(mgfMD)) != 1 {
+				return nil, newOpenSSLError("EVP_PKEY_CTX_ctrl failed")
+			}
+		}
 		// ctx takes ownership of label, so malloc a copy for OpenSSL to free.
 		// OpenSSL 1.1.1 and higher does not take ownership of the label if the length is zero,
 		// so better avoid the allocation.
@@ -154,7 +187,16 @@ func setupEVP(withKey withKeyFunc, padding C.int,
 			clabel = (*C.uchar)(C.malloc(C.size_t(len(label))))
 			copy((*[1 << 30]byte)(unsafe.Pointer(clabel))[:len(label)], label)
 		}
-		if C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, C.GO_EVP_PKEY_RSA, -1, C.GO_EVP_PKEY_CTRL_RSA_OAEP_LABEL, C.int(len(label)), unsafe.Pointer(clabel)) != 1 {
+		var ret C.int
+		if vMajor == 1 {
+			ret = C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, C.GO_EVP_PKEY_RSA, -1, C.GO_EVP_PKEY_CTRL_RSA_OAEP_LABEL, C.int(len(label)), unsafe.Pointer(clabel))
+		} else {
+			// OpenSSL 3 implements EVP_PKEY_CTX_set0_rsa_oaep_label as a function,
+			// instead of a macro around EVP_PKEY_CTX_ctrl, and it takes a different
+			// code path when the implementation is provided by FIPS provider.
+			ret = C.go_openssl_EVP_PKEY_CTX_set0_rsa_oaep_label(ctx, unsafe.Pointer(clabel), C.int(len(label)))
+		}
+		if ret != 1 {
 			if clabel != nil {
 				C.free(unsafe.Pointer(clabel))
 			}
@@ -173,7 +215,7 @@ func setupEVP(withKey withKeyFunc, padding C.int,
 			return nil, err
 		}
 		if saltLen != 0 {
-			if C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, C.GO_EVP_PKEY_RSA, -1, C.GO_EVP_PKEY_CTRL_RSA_PSS_SALTLEN, C.int(saltLen), nil) != 1 {
+			if C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, C.GO_EVP_PKEY_RSA, -1, C.GO_EVP_PKEY_CTRL_RSA_PSS_SALTLEN, saltLen, nil) != 1 {
 				return nil, newOpenSSLError("EVP_PKEY_CTX_ctrl failed")
 			}
 		}
@@ -201,10 +243,10 @@ func setupEVP(withKey withKeyFunc, padding C.int,
 }
 
 func cryptEVP(withKey withKeyFunc, padding C.int,
-	h hash.Hash, label []byte, saltLen int, ch crypto.Hash,
+	h, mgfHash hash.Hash, label []byte, saltLen C.int, ch crypto.Hash,
 	init initFunc, crypt cryptFunc, in []byte) ([]byte, error) {
 
-	ctx, err := setupEVP(withKey, padding, h, label, saltLen, ch, init)
+	ctx, err := setupEVP(withKey, padding, h, mgfHash, label, saltLen, ch, init)
 	if err != nil {
 		return nil, err
 	}
@@ -214,8 +256,8 @@ func cryptEVP(withKey withKeyFunc, padding C.int,
 	})
 	outLen := C.size_t(pkeySize)
 	out := make([]byte, pkeySize)
-	if crypt(ctx, base(out), &outLen, base(in), C.size_t(len(in))) != 1 {
-		return nil, newOpenSSLError("EVP_PKEY_decrypt/encrypt failed")
+	if err := crypt(ctx, base(out), &outLen, base(in), C.size_t(len(in))); err != nil {
+		return nil, err
 	}
 	// The size returned by EVP_PKEY_get_size() is only preliminary and not exact,
 	// so the final contents of the out buffer may be smaller.
@@ -223,57 +265,90 @@ func cryptEVP(withKey withKeyFunc, padding C.int,
 }
 
 func verifyEVP(withKey withKeyFunc, padding C.int,
-	h hash.Hash, label []byte, saltLen int, ch crypto.Hash,
+	h hash.Hash, label []byte, saltLen C.int, ch crypto.Hash,
 	init initFunc, verify verifyFunc,
 	sig, in []byte) error {
 
-	ctx, err := setupEVP(withKey, padding, h, label, saltLen, ch, init)
+	ctx, err := setupEVP(withKey, padding, h, nil, label, saltLen, ch, init)
 	if err != nil {
 		return err
 	}
 	defer C.go_openssl_EVP_PKEY_CTX_free(ctx)
-	if verify(ctx, base(sig), C.size_t(len(sig)), base(in), C.size_t(len(in))) != 1 {
-		return newOpenSSLError("EVP_PKEY_decrypt/encrypt failed")
-	}
-	return nil
+	return verify(ctx, base(sig), C.size_t(len(sig)), base(in), C.size_t(len(in)))
 }
 
-func evpEncrypt(withKey withKeyFunc, padding C.int, h hash.Hash, label, msg []byte) ([]byte, error) {
-	encryptInit := func(ctx C.GO_EVP_PKEY_CTX_PTR) C.int {
-		return C.go_openssl_EVP_PKEY_encrypt_init(ctx)
+func evpEncrypt(withKey withKeyFunc, padding C.int, h, mgfHash hash.Hash, label, msg []byte) ([]byte, error) {
+	encryptInit := func(ctx C.GO_EVP_PKEY_CTX_PTR) error {
+		if ret := C.go_openssl_EVP_PKEY_encrypt_init(ctx); ret != 1 {
+			return newOpenSSLError("EVP_PKEY_encrypt_init failed")
+		}
+		return nil
 	}
-	encrypt := func(ctx C.GO_EVP_PKEY_CTX_PTR, out *C.uchar, outLen *C.size_t, in *C.uchar, inLen C.size_t) C.int {
-		return C.go_openssl_EVP_PKEY_encrypt(ctx, out, outLen, in, inLen)
+	encrypt := func(ctx C.GO_EVP_PKEY_CTX_PTR, out *C.uchar, outLen *C.size_t, in *C.uchar, inLen C.size_t) error {
+		if ret := C.go_openssl_EVP_PKEY_encrypt(ctx, out, outLen, in, inLen); ret != 1 {
+			return newOpenSSLError("EVP_PKEY_encrypt failed")
+		}
+		return nil
 	}
-	return cryptEVP(withKey, padding, h, label, 0, 0, encryptInit, encrypt, msg)
+	return cryptEVP(withKey, padding, h, mgfHash, label, 0, 0, encryptInit, encrypt, msg)
 }
 
-func evpDecrypt(withKey withKeyFunc, padding C.int, h hash.Hash, label, msg []byte) ([]byte, error) {
-	decryptInit := func(ctx C.GO_EVP_PKEY_CTX_PTR) C.int {
-		return C.go_openssl_EVP_PKEY_decrypt_init(ctx)
+func evpDecrypt(withKey withKeyFunc, padding C.int, h, mgfHash hash.Hash, label, msg []byte) ([]byte, error) {
+	decryptInit := func(ctx C.GO_EVP_PKEY_CTX_PTR) error {
+		if ret := C.go_openssl_EVP_PKEY_decrypt_init(ctx); ret != 1 {
+			return newOpenSSLError("EVP_PKEY_decrypt_init failed")
+		}
+		return nil
 	}
-	decrypt := func(ctx C.GO_EVP_PKEY_CTX_PTR, out *C.uchar, outLen *C.size_t, in *C.uchar, inLen C.size_t) C.int {
-		return C.go_openssl_EVP_PKEY_decrypt(ctx, out, outLen, in, inLen)
+	decrypt := func(ctx C.GO_EVP_PKEY_CTX_PTR, out *C.uchar, outLen *C.size_t, in *C.uchar, inLen C.size_t) error {
+		if ret := C.go_openssl_EVP_PKEY_decrypt(ctx, out, outLen, in, inLen); ret != 1 {
+			return newOpenSSLError("EVP_PKEY_decrypt failed")
+		}
+		return nil
 	}
-	return cryptEVP(withKey, padding, h, label, 0, 0, decryptInit, decrypt, msg)
+	return cryptEVP(withKey, padding, h, mgfHash, label, 0, 0, decryptInit, decrypt, msg)
 }
 
-func evpSign(withKey withKeyFunc, padding C.int, saltLen int, h crypto.Hash, hashed []byte) ([]byte, error) {
-	signtInit := func(ctx C.GO_EVP_PKEY_CTX_PTR) C.int {
-		return C.go_openssl_EVP_PKEY_sign_init(ctx)
+func evpSign(withKey withKeyFunc, padding C.int, saltLen C.int, h crypto.Hash, hashed []byte) ([]byte, error) {
+	signtInit := func(ctx C.GO_EVP_PKEY_CTX_PTR) error {
+		if ret := C.go_openssl_EVP_PKEY_sign_init(ctx); ret != 1 {
+			return newOpenSSLError("EVP_PKEY_sign_init failed")
+		}
+		return nil
 	}
-	sign := func(ctx C.GO_EVP_PKEY_CTX_PTR, out *C.uchar, outLen *C.size_t, in *C.uchar, inLen C.size_t) C.int {
-		return C.go_openssl_EVP_PKEY_sign(ctx, out, outLen, in, inLen)
+	sign := func(ctx C.GO_EVP_PKEY_CTX_PTR, out *C.uchar, outLen *C.size_t, in *C.uchar, inLen C.size_t) error {
+		if ret := C.go_openssl_EVP_PKEY_sign(ctx, out, outLen, in, inLen); ret != 1 {
+			return newOpenSSLError("EVP_PKEY_sign failed")
+		}
+		return nil
 	}
-	return cryptEVP(withKey, padding, nil, nil, saltLen, h, signtInit, sign, hashed)
+	return cryptEVP(withKey, padding, nil, nil, nil, saltLen, h, signtInit, sign, hashed)
 }
 
-func evpVerify(withKey withKeyFunc, padding C.int, saltLen int, h crypto.Hash, sig, hashed []byte) error {
-	verifyInit := func(ctx C.GO_EVP_PKEY_CTX_PTR) C.int {
-		return C.go_openssl_EVP_PKEY_verify_init(ctx)
+func evpVerify(withKey withKeyFunc, padding C.int, saltLen C.int, h crypto.Hash, sig, hashed []byte) error {
+	verifyInit := func(ctx C.GO_EVP_PKEY_CTX_PTR) error {
+		if ret := C.go_openssl_EVP_PKEY_verify_init(ctx); ret != 1 {
+			return newOpenSSLError("EVP_PKEY_verify_init failed")
+		}
+		return nil
 	}
-	verify := func(ctx C.GO_EVP_PKEY_CTX_PTR, out *C.uchar, outLen C.size_t, in *C.uchar, inLen C.size_t) C.int {
-		return C.go_openssl_EVP_PKEY_verify(ctx, out, outLen, in, inLen)
+	verify := func(ctx C.GO_EVP_PKEY_CTX_PTR, out *C.uchar, outLen C.size_t, in *C.uchar, inLen C.size_t) error {
+		if ret := C.go_openssl_EVP_PKEY_verify(ctx, out, outLen, in, inLen); ret != 1 {
+			return newOpenSSLError("EVP_PKEY_verify failed")
+		}
+		return nil
 	}
 	return verifyEVP(withKey, padding, nil, nil, saltLen, h, verifyInit, verify, sig, hashed)
 }
+
+func newEVPPKEY(key C.GO_EC_KEY_PTR) (C.GO_EVP_PKEY_PTR, error) {
+	pkey := C.go_openssl_EVP_PKEY_new()
+	if pkey == nil {
+		return nil, newOpenSSLError("EVP_PKEY_new failed")
+	}
+	if C.go_openssl_EVP_PKEY_assign(pkey, C.GO_EVP_PKEY_EC, (unsafe.Pointer)(key)) != 1 {
+		C.go_openssl_EVP_PKEY_free(pkey)
+		return nil, newOpenSSLError("EVP_PKEY_assign failed")
+	}
+	return pkey, nil
+}
diff --git a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/goopenssl.c b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/goopenssl.c
index 7bbf741851..e5c3eea680 100644
--- a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/goopenssl.c
+++ b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/goopenssl.c
@@ -9,6 +9,27 @@
 #include <dlfcn.h>
 #include <stdio.h>
 
+int
+go_openssl_fips_enabled(void* handle)
+{
+    // For OpenSSL 1.x.
+    int (*FIPS_mode)(void);
+    FIPS_mode = (int (*)(void))dlsym(handle, "FIPS_mode");
+    if (FIPS_mode != NULL)
+        return FIPS_mode();
+
+    // For OpenSSL 3.x.
+    int (*EVP_default_properties_is_fips_enabled)(void*);
+    int (*OSSL_PROVIDER_available)(void*, const char*);
+    EVP_default_properties_is_fips_enabled = (int (*)(void*))dlsym(handle, "EVP_default_properties_is_fips_enabled"); 
+    OSSL_PROVIDER_available = (int (*)(void*, const char*))dlsym(handle, "OSSL_PROVIDER_available"); 
+    if (EVP_default_properties_is_fips_enabled != NULL && OSSL_PROVIDER_available != NULL &&
+        EVP_default_properties_is_fips_enabled(NULL) == 1 && OSSL_PROVIDER_available(NULL, "fips") == 1)
+            return 1;
+
+    return 0;
+}
+
 static unsigned long
 version_num(void* handle)
 {
@@ -47,12 +68,12 @@ int
 go_openssl_version_minor(void* handle)
 {
     unsigned int (*fn)(void);
-    // OPENSSL_version_major is supported since OpenSSL 3.
+    // OPENSSL_version_minor is supported since OpenSSL 3.
     fn = (unsigned int (*)(void))dlsym(handle, "OPENSSL_version_minor");
     if (fn != NULL)
         return (int)fn();
 
-    // If OPENSSL_version_major is not defined, try with OpenSSL 1 functions.
+    // If OPENSSL_version_minor is not defined, try with OpenSSL 1 functions.
     unsigned long num = version_num(handle);
     // OpenSSL version number follows this schema:
     // MNNFFPPS: major minor fix patch status.
@@ -70,6 +91,24 @@ go_openssl_version_minor(void* handle)
     return 0;
 }
 
+int
+go_openssl_version_feature(void* handle)
+{
+    unsigned int (*fn)(void);
+    // OPENSSL_version_minor is supported since OpenSSL 3.
+    // OpenSSL 3 has feature level always set to zero
+    fn = (unsigned int (*)(void))dlsym(handle, "OPENSSL_version_minor");
+    if (fn != NULL)
+        return 0;
+
+    // If OPENSSL_version_minor is not defined, try with OpenSSL 1 functions.
+    unsigned long num = version_num(handle);
+    // OpenSSL version number follows this schema:
+    // MNNFFPPS: major minor feature patch status.
+
+    return (num >> 12) & 0xff;
+}
+
 // Approach taken from .Net System.Security.Cryptography.Native
 // https://github.com/dotnet/runtime/blob/f64246ce08fb7a58221b2b7c8e68f69c02522b0d/src/libraries/Native/Unix/System.Security.Cryptography.Native/opensslshim.c
 
@@ -77,6 +116,7 @@ go_openssl_version_minor(void* handle)
 #define DEFINEFUNC_LEGACY_1_0(ret, func, args, argscall)       DEFINEFUNC(ret, func, args, argscall)
 #define DEFINEFUNC_LEGACY_1(ret, func, args, argscall)         DEFINEFUNC(ret, func, args, argscall)
 #define DEFINEFUNC_1_1(ret, func, args, argscall)              DEFINEFUNC(ret, func, args, argscall)
+#define DEFINEFUNC_1_1_1(ret, func, args, argscall)            DEFINEFUNC(ret, func, args, argscall)
 #define DEFINEFUNC_3_0(ret, func, args, argscall)              DEFINEFUNC(ret, func, args, argscall)
 #define DEFINEFUNC_RENAMED_1_1(ret, func, oldfunc, args, argscall) DEFINEFUNC(ret, func, args, argscall)
 #define DEFINEFUNC_RENAMED_3_0(ret, func, oldfunc, args, argscall) DEFINEFUNC(ret, func, args, argscall)
@@ -87,6 +127,7 @@ FOR_ALL_OPENSSL_FUNCTIONS
 #undef DEFINEFUNC_LEGACY_1_0
 #undef DEFINEFUNC_LEGACY_1
 #undef DEFINEFUNC_1_1
+#undef DEFINEFUNC_1_1_1
 #undef DEFINEFUNC_3_0
 #undef DEFINEFUNC_RENAMED_1_1
 #undef DEFINEFUNC_RENAMED_3_0
@@ -95,7 +136,7 @@ FOR_ALL_OPENSSL_FUNCTIONS
 // and assign them to their corresponding function pointer
 // defined in goopenssl.h.
 void
-go_openssl_load_functions(void* handle, int major, int minor)
+go_openssl_load_functions(void* handle, int major, int minor, int feature)
 {
 #define DEFINEFUNC_INTERNAL(name, func) \
     _g_##name = dlsym(handle, func);         \
@@ -117,6 +158,11 @@ go_openssl_load_functions(void* handle, int major, int minor)
     {                                                 \
         DEFINEFUNC_INTERNAL(func, #func)              \
     }
+#define DEFINEFUNC_1_1_1(ret, func, args, argscall)     \
+    if (major == 3 || (major == 1 && minor == 1 && feature == 1))     \
+    {                                                 \
+        DEFINEFUNC_INTERNAL(func, #func)              \
+    }
 #define DEFINEFUNC_3_0(ret, func, args, argscall)     \
     if (major == 3)                                   \
     {                                                 \
@@ -147,6 +193,7 @@ FOR_ALL_OPENSSL_FUNCTIONS
 #undef DEFINEFUNC_LEGACY_1_0
 #undef DEFINEFUNC_LEGACY_1
 #undef DEFINEFUNC_1_1
+#undef DEFINEFUNC_1_1_1
 #undef DEFINEFUNC_3_0
 #undef DEFINEFUNC_RENAMED_1_1
 #undef DEFINEFUNC_RENAMED_3_0
diff --git a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/goopenssl.h b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/goopenssl.h
index 9191b512e3..2a387ccbfa 100644
--- a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/goopenssl.h
+++ b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/goopenssl.h
@@ -7,10 +7,12 @@
 
 #include "openssl_funcs.h"
 
+int go_openssl_fips_enabled(void* handle);
 int go_openssl_version_major(void* handle);
 int go_openssl_version_minor(void* handle);
+int go_openssl_version_feature(void* handle);
 int go_openssl_thread_setup(void);
-void go_openssl_load_functions(void* handle, int major, int minor);
+void go_openssl_load_functions(void* handle, int major, int minor, int feature);
 
 // Define pointers to all the used OpenSSL functions.
 // Calling C function pointers from Go is currently not supported.
@@ -28,6 +30,8 @@ void go_openssl_load_functions(void* handle, int major, int minor);
     DEFINEFUNC(ret, func, args, argscall)
 #define DEFINEFUNC_1_1(ret, func, args, argscall)     \
     DEFINEFUNC(ret, func, args, argscall)
+#define DEFINEFUNC_1_1_1(ret, func, args, argscall)     \
+    DEFINEFUNC(ret, func, args, argscall)
 #define DEFINEFUNC_3_0(ret, func, args, argscall)     \
     DEFINEFUNC(ret, func, args, argscall)
 #define DEFINEFUNC_RENAMED_1_1(ret, func, oldfunc, args, argscall)     \
@@ -41,10 +45,25 @@ FOR_ALL_OPENSSL_FUNCTIONS
 #undef DEFINEFUNC_LEGACY_1_0
 #undef DEFINEFUNC_LEGACY_1
 #undef DEFINEFUNC_1_1
+#undef DEFINEFUNC_1_1_1
 #undef DEFINEFUNC_3_0
 #undef DEFINEFUNC_RENAMED_1_1
 #undef DEFINEFUNC_RENAMED_3_0
 
+// go_shaX is a SHA generic wrapper which hash p into out.
+// One shot sha functions are expected to be fast, so
+// we maximize performance by batching all cgo calls.
+static inline int
+go_shaX(GO_EVP_MD_PTR md, void *p, size_t n, void *out)
+{
+    GO_EVP_MD_CTX_PTR ctx = go_openssl_EVP_MD_CTX_new();
+    go_openssl_EVP_DigestInit_ex(ctx, md, NULL);
+    int ret = go_openssl_EVP_DigestUpdate(ctx, p, n) &&
+        go_openssl_EVP_DigestFinal_ex(ctx, out, NULL);
+    go_openssl_EVP_MD_CTX_free(ctx);
+    return ret;
+}
+
 // These wrappers allocate out_len on the C stack to avoid having to pass a pointer from Go, which would escape to the heap.
 // Use them only in situations where the output length can be safely discarded.
 static inline int
@@ -130,4 +149,4 @@ go_openssl_EVP_CIPHER_CTX_open_wrapper(const GO_EVP_CIPHER_CTX_PTR ctx,
         return 0;
 
     return 1;
-};
\ No newline at end of file
+};
diff --git a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/hmac.go b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/hmac.go
index 80f320b041..bb7c87fa48 100644
--- a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/hmac.go
+++ b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/hmac.go
@@ -14,6 +14,11 @@ import (
 	"unsafe"
 )
 
+var (
+	paramAlgHMAC = C.CString("HMAC")
+	paramDigest  = C.CString("digest")
+)
+
 // NewHMAC returns a new HMAC using OpenSSL.
 // The function h must return a hash implemented by
 // OpenSSL (for example, h could be openssl.NewSHA256).
@@ -38,19 +43,19 @@ func NewHMAC(h func() hash.Hash, key []byte) hash.Hash {
 		// we pass an "empty" key.
 		hkey = make([]byte, C.GO_EVP_MAX_MD_SIZE)
 	}
-	hmac := &opensslHMAC{
-		md:        md,
-		size:      ch.Size(),
-		blockSize: ch.BlockSize(),
-		key:       hkey,
-		ctx:       hmacCtxNew(),
+	switch vMajor {
+	case 1:
+		return newHMAC1(hkey, ch, md)
+	case 3:
+		return newHMAC3(hkey, ch, md)
+	default:
+		panic(errUnsuportedVersion())
 	}
-	runtime.SetFinalizer(hmac, (*opensslHMAC).finalize)
-	hmac.Reset()
-	return hmac
 }
 
-type opensslHMAC struct {
+// hmac1 implements hash.Hash
+// using functions available in OpenSSL 1.
+type hmac1 struct {
 	md        C.GO_EVP_MD_PTR
 	ctx       C.GO_HMAC_CTX_PTR
 	size      int
@@ -59,8 +64,21 @@ type opensslHMAC struct {
 	sum       []byte
 }
 
-func (h *opensslHMAC) Reset() {
-	hmacCtxReset(h.ctx)
+func newHMAC1(key []byte, h hash.Hash, md C.GO_EVP_MD_PTR) *hmac1 {
+	hmac := &hmac1{
+		md:        md,
+		size:      h.Size(),
+		blockSize: h.BlockSize(),
+		key:       key,
+		ctx:       hmac1CtxNew(),
+	}
+	runtime.SetFinalizer(hmac, (*hmac1).finalize)
+	hmac.Reset()
+	return hmac
+}
+
+func (h *hmac1) Reset() {
+	hmac1CtxReset(h.ctx)
 
 	if C.go_openssl_HMAC_Init_ex(h.ctx, unsafe.Pointer(&h.key[0]), C.int(len(h.key)), h.md, nil) == 0 {
 		panic("openssl: HMAC_Init failed")
@@ -73,11 +91,11 @@ func (h *opensslHMAC) Reset() {
 	h.sum = nil
 }
 
-func (h *opensslHMAC) finalize() {
-	hmacCtxFree(h.ctx)
+func (h *hmac1) finalize() {
+	hmac1CtxFree(h.ctx)
 }
 
-func (h *opensslHMAC) Write(p []byte) (int, error) {
+func (h *hmac1) Write(p []byte) (int, error) {
 	if len(p) > 0 {
 		C.go_openssl_HMAC_Update(h.ctx, base(p), C.size_t(len(p)))
 	}
@@ -85,15 +103,15 @@ func (h *opensslHMAC) Write(p []byte) (int, error) {
 	return len(p), nil
 }
 
-func (h *opensslHMAC) Size() int {
+func (h *hmac1) Size() int {
 	return h.size
 }
 
-func (h *opensslHMAC) BlockSize() int {
+func (h *hmac1) BlockSize() int {
 	return h.blockSize
 }
 
-func (h *opensslHMAC) Sum(in []byte) []byte {
+func (h *hmac1) Sum(in []byte) []byte {
 	if h.sum == nil {
 		size := h.Size()
 		h.sum = make([]byte, size)
@@ -102,8 +120,8 @@ func (h *opensslHMAC) Sum(in []byte) []byte {
 	// that Sum has no effect on the underlying stream.
 	// In particular it is OK to Sum, then Write more, then Sum again,
 	// and the second Sum acts as if the first didn't happen.
-	ctx2 := hmacCtxNew()
-	defer hmacCtxFree(ctx2)
+	ctx2 := hmac1CtxNew()
+	defer hmac1CtxFree(ctx2)
 	if C.go_openssl_HMAC_CTX_copy(ctx2, h.ctx) == 0 {
 		panic("openssl: HMAC_CTX_copy failed")
 	}
@@ -111,7 +129,7 @@ func (h *opensslHMAC) Sum(in []byte) []byte {
 	return append(in, h.sum...)
 }
 
-func hmacCtxNew() C.GO_HMAC_CTX_PTR {
+func hmac1CtxNew() C.GO_HMAC_CTX_PTR {
 	if vMajor == 1 && vMinor == 0 {
 		// 0x120 is the sizeof value when building against OpenSSL 1.0.2 on Ubuntu 16.04.
 		ctx := (C.GO_HMAC_CTX_PTR)(C.malloc(0x120))
@@ -123,7 +141,7 @@ func hmacCtxNew() C.GO_HMAC_CTX_PTR {
 	return C.go_openssl_HMAC_CTX_new()
 }
 
-func hmacCtxReset(ctx C.GO_HMAC_CTX_PTR) {
+func hmac1CtxReset(ctx C.GO_HMAC_CTX_PTR) {
 	if ctx == nil {
 		return
 	}
@@ -135,7 +153,7 @@ func hmacCtxReset(ctx C.GO_HMAC_CTX_PTR) {
 	C.go_openssl_HMAC_CTX_reset(ctx)
 }
 
-func hmacCtxFree(ctx C.GO_HMAC_CTX_PTR) {
+func hmac1CtxFree(ctx C.GO_HMAC_CTX_PTR) {
 	if ctx == nil {
 		return
 	}
@@ -146,3 +164,89 @@ func hmacCtxFree(ctx C.GO_HMAC_CTX_PTR) {
 	}
 	C.go_openssl_HMAC_CTX_free(ctx)
 }
+
+// hmac3 implements hash.Hash
+// using functions available in OpenSSL 3.
+type hmac3 struct {
+	md        C.GO_EVP_MAC_PTR
+	ctx       C.GO_EVP_MAC_CTX_PTR
+	params    [2]C.OSSL_PARAM
+	size      int
+	blockSize int
+	key       []byte
+	sum       []byte
+}
+
+func newHMAC3(key []byte, h hash.Hash, md C.GO_EVP_MD_PTR) *hmac3 {
+	mac := C.go_openssl_EVP_MAC_fetch(nil, paramAlgHMAC, nil)
+	ctx := C.go_openssl_EVP_MAC_CTX_new(mac)
+	if ctx == nil {
+		panic("openssl: EVP_MAC_CTX_new failed")
+	}
+	digest := C.go_openssl_EVP_MD_get0_name(md)
+	params := [2]C.OSSL_PARAM{
+		C.go_openssl_OSSL_PARAM_construct_utf8_string(paramDigest, digest, 0),
+		C.go_openssl_OSSL_PARAM_construct_end(),
+	}
+	hmac := &hmac3{
+		md:        mac,
+		ctx:       ctx,
+		params:    params,
+		size:      h.Size(),
+		blockSize: h.BlockSize(),
+		key:       key,
+	}
+	runtime.SetFinalizer(hmac, (*hmac3).finalize)
+	hmac.Reset()
+	return hmac
+}
+
+func (h *hmac3) Reset() {
+	if C.go_openssl_EVP_MAC_init(h.ctx, base(h.key), C.size_t(len(h.key)), &h.params[0]) == 0 {
+		panic(newOpenSSLError("EVP_MAC_init failed"))
+	}
+	runtime.KeepAlive(h) // Next line will keep h alive too; just making doubly sure.
+	h.sum = nil
+}
+
+func (h *hmac3) finalize() {
+	C.go_openssl_EVP_MAC_free(h.md)
+	if h.ctx == nil {
+		return
+	}
+	C.go_openssl_EVP_MAC_CTX_free(h.ctx)
+}
+
+func (h *hmac3) Write(p []byte) (int, error) {
+	if len(p) > 0 {
+		C.go_openssl_EVP_MAC_update(h.ctx, base(p), C.size_t(len(p)))
+	}
+	runtime.KeepAlive(h)
+	return len(p), nil
+}
+
+func (h *hmac3) Size() int {
+	return h.size
+}
+
+func (h *hmac3) BlockSize() int {
+	return h.blockSize
+}
+
+func (h *hmac3) Sum(in []byte) []byte {
+	if h.sum == nil {
+		size := h.Size()
+		h.sum = make([]byte, size)
+	}
+	// Make copy of context because Go hash.Hash mandates
+	// that Sum has no effect on the underlying stream.
+	// In particular it is OK to Sum, then Write more, then Sum again,
+	// and the second Sum acts as if the first didn't happen.
+	ctx2 := C.go_openssl_EVP_MAC_CTX_dup(h.ctx)
+	if ctx2 == nil {
+		panic("openssl: EVP_MAC_CTX_dup failed")
+	}
+	defer C.go_openssl_EVP_MAC_CTX_free(ctx2)
+	C.go_openssl_EVP_MAC_final(ctx2, base(h.sum), nil, C.size_t(len(h.sum)))
+	return append(in, h.sum...)
+}
diff --git a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/openssl.go b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/openssl.go
index 2c354e1df0..b360a9f9bc 100644
--- a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/openssl.go
+++ b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/openssl.go
@@ -13,7 +13,7 @@ package openssl
 import "C"
 import (
 	"errors"
-	"math/big"
+	"math/bits"
 	"strconv"
 	"strings"
 	"sync"
@@ -24,18 +24,16 @@ import (
 var (
 	providerNameFips    = C.CString("fips")
 	providerNameDefault = C.CString("default")
-	propFipsYes         = C.CString("fips=yes")
-	propFipsNo          = C.CString("fips=no")
-	algProve            = C.CString("SHA2-256")
 )
 
 var (
 	initOnce sync.Once
 	// errInit is set when first calling Init().
 	errInit error
-	// vMajor and vMinor hold the major/minor OpenSSL version.
-	// It is only populated if Init has been called.
-	vMajor, vMinor int
+	// vMajor, vMinor and vFeature hold the major/minor/feature
+	// OpenSSL version. It is only populated if Init has been
+	// called.
+	vMajor, vMinor, vFeature int
 )
 
 // knownVersions is a list of supported and well-known libcrypto.so suffixes in decreasing version order.
@@ -49,7 +47,7 @@ var (
 var knownVersions = [...]string{"3", "1.1", "11", "111", "1.0.2", "1.0.0", "10"}
 
 func errUnsuportedVersion() error {
-	return errors.New("openssl: OpenSSL version: " + strconv.Itoa(vMajor) + "." + strconv.Itoa(vMinor))
+	return errors.New("openssl: OpenSSL version: " + strconv.Itoa(vMajor) + "." + strconv.Itoa(vMinor) + "." + strconv.Itoa(vFeature))
 }
 
 // Init loads and initializes OpenSSL.
@@ -74,7 +72,8 @@ func Init() error {
 
 		vMajor = int(C.go_openssl_version_major(handle))
 		vMinor = int(C.go_openssl_version_minor(handle))
-		if vMajor == -1 || vMinor == -1 {
+		vFeature = int(C.go_openssl_version_feature(handle))
+		if vMajor == -1 || vMinor == -1 || vFeature == -1 {
 			errInit = errors.New("openssl: can't retrieve OpenSSL version")
 			return
 		}
@@ -90,7 +89,7 @@ func Init() error {
 			return
 		}
 
-		C.go_openssl_load_functions(handle, C.int(vMajor), C.int(vMinor))
+		C.go_openssl_load_functions(handle, C.int(vMajor), C.int(vMinor), C.int(vFeature))
 		C.go_openssl_OPENSSL_init()
 		if vMajor == 1 && vMinor == 0 {
 			if C.go_openssl_thread_setup() != 1 {
@@ -126,26 +125,33 @@ func loadLibrary(version string) (unsafe.Pointer, error) {
 		}
 		return handle, nil
 	}
+	var fallbackHandle unsafe.Pointer
 	for _, v := range knownVersions {
 		handle := dlopen(v)
-		if handle != nil {
+		if handle == nil {
+			continue
+		}
+		if C.go_openssl_fips_enabled(handle) == 1 {
+			// Found a FIPS enabled version, use it.
+			if fallbackHandle != nil {
+				// If we found a FIPS enabled version but we already have a fallback
+				// version, close the fallback version.
+				C.dlclose(fallbackHandle)
+			}
 			return handle, nil
 		}
+		if fallbackHandle == nil {
+			// Remember the first version that exists but is not FIPS enabled
+			// in case we don't find any FIPS enabled version.
+			fallbackHandle = handle
+		} else {
+			C.dlclose(handle)
+		}
 	}
-	return nil, errors.New("openssl: can't load libcrypto.so using any known version suffix")
-}
-
-// providerAvailable looks through provider's digests
-// checking if there is any that matches the props query.
-func providerAvailable(props *C.char) bool {
-	C.go_openssl_ERR_set_mark()
-	md := C.go_openssl_EVP_MD_fetch(nil, algProve, props)
-	C.go_openssl_ERR_pop_to_mark()
-	if md == nil {
-		return false
+	if fallbackHandle != nil {
+		return fallbackHandle, nil
 	}
-	C.go_openssl_EVP_MD_free(md)
-	return true
+	return nil, errors.New("openssl: can't load libcrypto.so using any known version suffix")
 }
 
 // FIPS returns true if OpenSSL is running in FIPS mode, else returns false.
@@ -159,7 +165,7 @@ func FIPS() bool {
 		}
 		// EVP_default_properties_is_fips_enabled can return true even if the FIPS provider isn't loaded,
 		// it is only based on the default properties.
-		return providerAvailable(propFipsYes)
+		return C.go_openssl_OSSL_PROVIDER_available(nil, providerNameFips) == 1
 	default:
 		panic(errUnsuportedVersion())
 	}
@@ -167,45 +173,41 @@ func FIPS() bool {
 
 // SetFIPS enables or disables FIPS mode.
 //
-// It implements the following provider fallback logic for OpenSSL 3:
-//    - The "fips" provider is loaded if enabled=true and no loaded provider matches "fips=yes".
-//    - The "default" provider is loaded if enabled=false and no loaded provider matches "fips=no".
-// This logic allows advanced users to define their own providers that match "fips=yes" and "fips=no" using the OpenSSL config file.
+// On OpenSSL 3, the `fips` provider is loaded if enabled is true,
+// else the `default` provider is loaded.
 func SetFIPS(enabled bool) error {
+	var mode C.int
+	if enabled {
+		mode = C.int(1)
+	} else {
+		mode = C.int(0)
+	}
 	switch vMajor {
 	case 1:
-		var mode C.int
-		if enabled {
-			mode = C.int(1)
-		} else {
-			mode = C.int(0)
-		}
 		if C.go_openssl_FIPS_mode_set(mode) != 1 {
 			return newOpenSSLError("openssl: FIPS_mode_set")
 		}
 		return nil
 	case 3:
-		var props, provName *C.char
+		var provName *C.char
 		if enabled {
-			props = propFipsYes
 			provName = providerNameFips
 		} else {
-			props = propFipsNo
 			provName = providerNameDefault
 		}
-		// Check if there is any provider that matches props.
-		if !providerAvailable(props) {
+		// Check if provName is not loaded.
+		if C.go_openssl_OSSL_PROVIDER_available(nil, provName) == 0 {
 			// If not, fallback to provName provider.
 			if C.go_openssl_OSSL_PROVIDER_load(nil, provName) == nil {
-				return newOpenSSLError("openssl: OSSL_PROVIDER_try_load")
+				return newOpenSSLError("openssl: OSSL_PROVIDER_load")
 			}
 			// Make sure we now have a provider available.
-			if !providerAvailable(props) {
+			if C.go_openssl_OSSL_PROVIDER_available(nil, provName) == 0 {
 				return fail("SetFIPS(" + strconv.FormatBool(enabled) + ") not supported")
 			}
 		}
-		if C.go_openssl_EVP_set_default_properties(nil, props) != 1 {
-			return newOpenSSLError("openssl: EVP_set_default_properties")
+		if C.go_openssl_EVP_default_properties_enable_fips(nil, mode) != 1 {
+			return newOpenSSLError("openssl: EVP_default_properties_enable_fips")
 		}
 		return nil
 	default:
@@ -242,19 +244,62 @@ type fail string
 
 func (e fail) Error() string { return "openssl: " + string(e) + " failed" }
 
-func bigToBN(x *big.Int) C.GO_BIGNUM_PTR {
-	if x == nil {
+const wordBytes = bits.UintSize / 8
+
+func wbase(b BigInt) *C.uchar {
+	if len(b) == 0 {
 		return nil
 	}
-	raw := x.Bytes()
-	return C.go_openssl_BN_bin2bn(base(raw), C.int(len(raw)), nil)
+	return (*C.uchar)(unsafe.Pointer(&b[0]))
 }
 
-func bnToBig(bn C.GO_BIGNUM_PTR) *big.Int {
+func bytesToBN(x []byte) C.GO_BIGNUM_PTR {
+	if len(x) == 0 {
+		return nil
+	}
+	return C.go_openssl_BN_bin2bn(base(x), C.int(len(x)), nil)
+}
+
+func bigToBN(x BigInt) C.GO_BIGNUM_PTR {
+	if len(x) == 0 {
+		return nil
+	}
+	return C.go_openssl_BN_lebin2bn(wbase(x), C.int(len(x)*wordBytes), nil)
+}
+
+func bnToBig(bn C.GO_BIGNUM_PTR) BigInt {
 	if bn == nil {
 		return nil
 	}
-	raw := make([]byte, (C.go_openssl_BN_num_bits(bn)+7)/8)
-	n := C.go_openssl_BN_bn2bin(bn, base(raw))
-	return new(big.Int).SetBytes(raw[:n])
+	x := make(BigInt, C.go_openssl_BN_num_bits(bn))
+	if C.go_openssl_BN_bn2lebinpad(bn, wbase(x), C.int(len(x)*wordBytes)) == 0 {
+		panic("openssl: bignum conversion failed")
+	}
+	return x
+}
+
+// noescape hides a pointer from escape analysis. noescape is
+// the identity function but escape analysis doesn't think the
+// output depends on the input. noescape is inlined and currently
+// compiles down to zero instructions.
+// USE CAREFULLY!
+//
+//go:nosplit
+func noescape(p unsafe.Pointer) unsafe.Pointer {
+	x := uintptr(p)
+	return unsafe.Pointer(x ^ 0)
+}
+
+var zero byte
+
+// addr converts p to its base addr, including a noescape along the way.
+// If p is nil, addr returns a non-nil pointer, so that the result can always
+// be dereferenced.
+//
+//go:nosplit
+func addr(p []byte) *byte {
+	if len(p) == 0 {
+		return &zero
+	}
+	return (*byte)(noescape(unsafe.Pointer(&p[0])))
 }
diff --git a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/openssl_funcs.h b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/openssl_funcs.h
index 95024cf8ec..cbc2d880c2 100644
--- a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/openssl_funcs.h
+++ b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/openssl_funcs.h
@@ -38,9 +38,13 @@ enum {
 
 // #include <openssl/ec.h>
 enum {
-    GO_EVP_PKEY_CTRL_EC_PARAMGEN_CURVE_NID = 0x1001
+    GO_EVP_PKEY_CTRL_EC_PARAMGEN_CURVE_NID = 0x1001,
 };
 
+typedef enum {
+    GO_POINT_CONVERSION_UNCOMPRESSED = 4,
+} point_conversion_form_t;
+
 // #include <openssl/obj_mac.h>
 enum {
     GO_NID_X9_62_prime256v1 = 415,
@@ -55,9 +59,14 @@ enum {
     GO_RSA_NO_PADDING = 3,
     GO_RSA_PKCS1_OAEP_PADDING = 4,
     GO_RSA_PKCS1_PSS_PADDING = 6,
+    GO_RSA_PSS_SALTLEN_DIGEST = -1,
+    GO_RSA_PSS_SALTLEN_AUTO = -2,
+    GO_RSA_PSS_SALTLEN_MAX_SIGN = -2,
+    GO_RSA_PSS_SALTLEN_MAX = -3,
     GO_EVP_PKEY_CTRL_RSA_PADDING = 0x1001,
     GO_EVP_PKEY_CTRL_RSA_PSS_SALTLEN = 0x1002,
     GO_EVP_PKEY_CTRL_RSA_KEYGEN_BITS = 0x1003,
+    GO_EVP_PKEY_CTRL_RSA_MGF1_MD = 0x1005,
     GO_EVP_PKEY_CTRL_RSA_OAEP_MD = 0x1009,
     GO_EVP_PKEY_CTRL_RSA_OAEP_LABEL = 0x100A
 };
@@ -79,6 +88,21 @@ typedef void* GO_EC_KEY_PTR;
 typedef void* GO_EC_POINT_PTR;
 typedef void* GO_EC_GROUP_PTR;
 typedef void* GO_RSA_PTR;
+typedef void* GO_EVP_MAC_PTR;
+typedef void* GO_EVP_MAC_CTX_PTR;
+
+// OSSL_PARAM does not follow the GO_FOO_PTR pattern
+// because it is not passed around as a pointer but on the stack.
+// We can't abstract it away by using a void*.
+// Copied from
+// https://github.com/openssl/openssl/blob/fcae2ae4f675def607d338b7945b9af1dd9bb746/include/openssl/core.h#L82-L88.
+typedef struct {
+    const char *key;
+    unsigned int data_type;
+    void *data;
+    size_t data_size;
+    size_t return_size;
+} OSSL_PARAM;
 
 // List of all functions from the libcrypto that are used in this package.
 // Forgetting to add a function here results in build failure with message reporting the function
@@ -126,8 +150,6 @@ typedef void* GO_RSA_PTR;
 // #include <openssl/provider.h>
 // #endif
 #define FOR_ALL_OPENSSL_FUNCTIONS \
-DEFINEFUNC(int, ERR_set_mark, (void), ()) \
-DEFINEFUNC(int, ERR_pop_to_mark, (void), ()) \
 DEFINEFUNC(unsigned long, ERR_get_error, (void), ()) \
 DEFINEFUNC(void, ERR_error_string_n, (unsigned long e, char *buf, size_t len), (e, buf, len)) \
 DEFINEFUNC_RENAMED_1_1(const char *, OpenSSL_version, SSLeay_version, (int type), (type)) \
@@ -141,25 +163,32 @@ DEFINEFUNC_1_1(int, OPENSSL_init_crypto, (uint64_t ops, const GO_OPENSSL_INIT_SE
 DEFINEFUNC_LEGACY_1(int, FIPS_mode, (void), ()) \
 DEFINEFUNC_LEGACY_1(int, FIPS_mode_set, (int r), (r)) \
 DEFINEFUNC_3_0(int, EVP_default_properties_is_fips_enabled, (GO_OSSL_LIB_CTX_PTR libctx), (libctx)) \
-DEFINEFUNC_3_0(int, EVP_set_default_properties, (GO_OSSL_LIB_CTX_PTR libctx, const char *propq), (libctx, propq)) \
+DEFINEFUNC_3_0(int, EVP_default_properties_enable_fips, (GO_OSSL_LIB_CTX_PTR libctx, int enable), (libctx, enable)) \
 DEFINEFUNC_3_0(GO_OSSL_PROVIDER_PTR, OSSL_PROVIDER_load, (GO_OSSL_LIB_CTX_PTR libctx, const char *name), (libctx, name)) \
+DEFINEFUNC_3_0(int, OSSL_PROVIDER_available, (GO_OSSL_LIB_CTX_PTR libctx, const char *name), (libctx, name)) \
 DEFINEFUNC(int, RAND_bytes, (unsigned char* arg0, int arg1), (arg0, arg1)) \
+DEFINEFUNC(int, EVP_DigestInit, (GO_EVP_MD_CTX_PTR ctx, const GO_EVP_MD_PTR type), (ctx, type)) \
 DEFINEFUNC(int, EVP_DigestInit_ex, (GO_EVP_MD_CTX_PTR ctx, const GO_EVP_MD_PTR type, GO_ENGINE_PTR impl), (ctx, type, impl)) \
 DEFINEFUNC(int, EVP_DigestUpdate, (GO_EVP_MD_CTX_PTR ctx, const void *d, size_t cnt), (ctx, d, cnt)) \
 DEFINEFUNC(int, EVP_DigestFinal_ex, (GO_EVP_MD_CTX_PTR ctx, unsigned char *md, unsigned int *s), (ctx, md, s)) \
+DEFINEFUNC(int, EVP_DigestFinal, (GO_EVP_MD_CTX_PTR ctx, unsigned char *md, unsigned int *s), (ctx, md, s)) \
 DEFINEFUNC_RENAMED_1_1(GO_EVP_MD_CTX_PTR, EVP_MD_CTX_new, EVP_MD_CTX_create, (), ()) \
 DEFINEFUNC_RENAMED_1_1(void, EVP_MD_CTX_free, EVP_MD_CTX_destroy, (GO_EVP_MD_CTX_PTR ctx), (ctx)) \
 DEFINEFUNC(int, EVP_MD_CTX_copy_ex, (GO_EVP_MD_CTX_PTR out, const GO_EVP_MD_CTX_PTR in), (out, in)) \
+DEFINEFUNC(int, EVP_MD_CTX_copy, (GO_EVP_MD_CTX_PTR out, const GO_EVP_MD_CTX_PTR in), (out, in)) \
 DEFINEFUNC_RENAMED_1_1(int, EVP_MD_CTX_reset, EVP_MD_CTX_cleanup, (GO_EVP_MD_CTX_PTR ctx), (ctx)) \
+DEFINEFUNC_3_0(const char *, EVP_MD_get0_name, (const GO_EVP_MD_PTR md), (md)) \
 DEFINEFUNC(const GO_EVP_MD_PTR, EVP_md5, (void), ()) \
 DEFINEFUNC(const GO_EVP_MD_PTR, EVP_sha1, (void), ()) \
 DEFINEFUNC(const GO_EVP_MD_PTR, EVP_sha224, (void), ()) \
 DEFINEFUNC(const GO_EVP_MD_PTR, EVP_sha256, (void), ()) \
 DEFINEFUNC(const GO_EVP_MD_PTR, EVP_sha384, (void), ()) \
 DEFINEFUNC(const GO_EVP_MD_PTR, EVP_sha512, (void), ()) \
+DEFINEFUNC_1_1_1(const GO_EVP_MD_PTR, EVP_sha3_224, (void), ()) \
+DEFINEFUNC_1_1_1(const GO_EVP_MD_PTR, EVP_sha3_256, (void), ()) \
+DEFINEFUNC_1_1_1(const GO_EVP_MD_PTR, EVP_sha3_384, (void), ()) \
+DEFINEFUNC_1_1_1(const GO_EVP_MD_PTR, EVP_sha3_512, (void), ()) \
 DEFINEFUNC_1_1(const GO_EVP_MD_PTR, EVP_md5_sha1, (void), ()) \
-DEFINEFUNC_3_0(GO_EVP_MD_PTR, EVP_MD_fetch, (GO_OSSL_LIB_CTX_PTR ctx, const char *algorithm, const char *properties), (ctx, algorithm, properties)) \
-DEFINEFUNC_3_0(void, EVP_MD_free, (GO_EVP_MD_PTR md), (md)) \
 DEFINEFUNC_RENAMED_3_0(int, EVP_MD_get_size, EVP_MD_size, (const GO_EVP_MD_PTR arg0), (arg0)) \
 DEFINEFUNC_LEGACY_1_0(void, HMAC_CTX_init, (GO_HMAC_CTX_PTR arg0), (arg0)) \
 DEFINEFUNC_LEGACY_1_0(void, HMAC_CTX_cleanup, (GO_HMAC_CTX_PTR arg0), (arg0)) \
@@ -180,15 +209,24 @@ DEFINEFUNC(void, BN_clear_free, (GO_BIGNUM_PTR arg0), (arg0)) \
 DEFINEFUNC(int, BN_num_bits, (const GO_BIGNUM_PTR arg0), (arg0)) \
 DEFINEFUNC(GO_BIGNUM_PTR, BN_bin2bn, (const unsigned char *arg0, int arg1, GO_BIGNUM_PTR arg2), (arg0, arg1, arg2)) \
 DEFINEFUNC(int, BN_bn2bin, (const GO_BIGNUM_PTR arg0, unsigned char *arg1), (arg0, arg1)) \
+/* bn_lebin2bn, bn_bn2lebinpad and BN_bn2binpad are not exported in any OpenSSL 1.0.2, but they exist. */ \
+/*check:from=1.1.0*/ DEFINEFUNC_RENAMED_1_1(GO_BIGNUM_PTR, BN_lebin2bn, bn_lebin2bn, (const unsigned char *s, int len, GO_BIGNUM_PTR ret), (s, len, ret)) \
+/*check:from=1.1.0*/ DEFINEFUNC_RENAMED_1_1(int, BN_bn2lebinpad, bn_bn2lebinpad, (const GO_BIGNUM_PTR a, unsigned char *to, int tolen), (a, to, tolen)) \
+/*check:from=1.1.0*/ DEFINEFUNC_RENAMED_1_1(int, BN_bn2binpad, bn_bn2binpad, (const GO_BIGNUM_PTR a, unsigned char *to, int tolen), (a, to, tolen)) \
 DEFINEFUNC(void, EC_GROUP_free, (GO_EC_GROUP_PTR arg0), (arg0)) \
 DEFINEFUNC(GO_EC_POINT_PTR, EC_POINT_new, (const GO_EC_GROUP_PTR arg0), (arg0)) \
 DEFINEFUNC(void, EC_POINT_free, (GO_EC_POINT_PTR arg0), (arg0)) \
 DEFINEFUNC(int, EC_POINT_get_affine_coordinates_GFp, (const GO_EC_GROUP_PTR arg0, const GO_EC_POINT_PTR arg1, GO_BIGNUM_PTR arg2, GO_BIGNUM_PTR arg3, GO_BN_CTX_PTR arg4), (arg0, arg1, arg2, arg3, arg4)) \
+DEFINEFUNC(size_t, EC_POINT_point2oct, (const GO_EC_GROUP_PTR group, const GO_EC_POINT_PTR p, point_conversion_form_t form, unsigned char *buf, size_t len, GO_BN_CTX_PTR ctx), (group, p, form, buf, len, ctx)) \
+DEFINEFUNC_LEGACY_1_0(int, EC_POINT_oct2point, (const GO_EC_GROUP_PTR group, GO_EC_POINT_PTR p, const unsigned char *buf, size_t len, GO_BN_CTX_PTR ctx), (group, p, buf, len, ctx)) \
+DEFINEFUNC(int, EC_POINT_mul, (const GO_EC_GROUP_PTR group, GO_EC_POINT_PTR r, const GO_BIGNUM_PTR n, const GO_EC_POINT_PTR q, const GO_BIGNUM_PTR m, GO_BN_CTX_PTR ctx), (group, r, n, q, m, ctx)) \
 DEFINEFUNC(GO_EC_KEY_PTR, EC_KEY_new_by_curve_name, (int arg0), (arg0)) \
 DEFINEFUNC(int, EC_KEY_set_public_key_affine_coordinates, (GO_EC_KEY_PTR key, GO_BIGNUM_PTR x, GO_BIGNUM_PTR y), (key, x, y)) \
+DEFINEFUNC_LEGACY_1_0(int, EC_KEY_set_public_key, (GO_EC_KEY_PTR key, const GO_EC_POINT_PTR pub), (key, pub)) \
 DEFINEFUNC(void, EC_KEY_free, (GO_EC_KEY_PTR arg0), (arg0)) \
 DEFINEFUNC(const GO_EC_GROUP_PTR, EC_KEY_get0_group, (const GO_EC_KEY_PTR arg0), (arg0)) \
 DEFINEFUNC(int, EC_KEY_set_private_key, (GO_EC_KEY_PTR arg0, const GO_BIGNUM_PTR arg1), (arg0, arg1)) \
+DEFINEFUNC_1_1(int, EC_KEY_oct2key, (GO_EC_KEY_PTR eckey, const unsigned char *buf, size_t len, GO_BN_CTX_PTR ctx), (eckey, buf, len, ctx)) \
 DEFINEFUNC(const GO_BIGNUM_PTR, EC_KEY_get0_private_key, (const GO_EC_KEY_PTR arg0), (arg0)) \
 DEFINEFUNC(const GO_EC_POINT_PTR, EC_KEY_get0_public_key, (const GO_EC_KEY_PTR arg0), (arg0)) \
 DEFINEFUNC(GO_RSA_PTR, RSA_new, (void), ()) \
@@ -219,9 +257,10 @@ DEFINEFUNC(const GO_EVP_CIPHER_PTR, EVP_aes_256_gcm, (void), ()) \
 DEFINEFUNC(void, EVP_CIPHER_CTX_free, (GO_EVP_CIPHER_CTX_PTR arg0), (arg0)) \
 DEFINEFUNC(int, EVP_CIPHER_CTX_ctrl, (GO_EVP_CIPHER_CTX_PTR ctx, int type, int arg, void *ptr), (ctx, type, arg, ptr)) \
 DEFINEFUNC(GO_EVP_PKEY_PTR, EVP_PKEY_new, (void), ()) \
-/* EVP_PKEY_size pkey parameter is const since OpenSSL 1.1.1. */ \
+/* EVP_PKEY_size and EVP_PKEY_get_bits pkey parameter is const since OpenSSL 1.1.1. */ \
 /* Exclude it from headercheck tool when using previous OpenSSL versions. */ \
 /*check:from=1.1.1*/ DEFINEFUNC_RENAMED_3_0(int, EVP_PKEY_get_size, EVP_PKEY_size, (const GO_EVP_PKEY_PTR pkey), (pkey)) \
+/*check:from=1.1.1*/ DEFINEFUNC_RENAMED_3_0(int, EVP_PKEY_get_bits, EVP_PKEY_bits, (const GO_EVP_PKEY_PTR pkey), (pkey)) \
 DEFINEFUNC(void, EVP_PKEY_free, (GO_EVP_PKEY_PTR arg0), (arg0)) \
 DEFINEFUNC(GO_EC_KEY_PTR, EVP_PKEY_get1_EC_KEY, (GO_EVP_PKEY_PTR pkey), (pkey)) \
 DEFINEFUNC(GO_RSA_PTR, EVP_PKEY_get1_RSA, (GO_EVP_PKEY_PTR pkey), (pkey)) \
@@ -239,4 +278,19 @@ DEFINEFUNC(int, EVP_PKEY_decrypt_init, (GO_EVP_PKEY_CTX_PTR arg0), (arg0)) \
 DEFINEFUNC(int, EVP_PKEY_encrypt_init, (GO_EVP_PKEY_CTX_PTR arg0), (arg0)) \
 DEFINEFUNC(int, EVP_PKEY_sign_init, (GO_EVP_PKEY_CTX_PTR arg0), (arg0)) \
 DEFINEFUNC(int, EVP_PKEY_verify_init, (GO_EVP_PKEY_CTX_PTR arg0), (arg0)) \
-DEFINEFUNC(int, EVP_PKEY_sign, (GO_EVP_PKEY_CTX_PTR arg0, unsigned char *arg1, size_t *arg2, const unsigned char *arg3, size_t arg4), (arg0, arg1, arg2, arg3, arg4))
+DEFINEFUNC(int, EVP_PKEY_sign, (GO_EVP_PKEY_CTX_PTR arg0, unsigned char *arg1, size_t *arg2, const unsigned char *arg3, size_t arg4), (arg0, arg1, arg2, arg3, arg4)) \
+DEFINEFUNC(int, EVP_PKEY_derive_init, (GO_EVP_PKEY_CTX_PTR ctx), (ctx)) \
+DEFINEFUNC(int, EVP_PKEY_derive_set_peer, (GO_EVP_PKEY_CTX_PTR ctx, GO_EVP_PKEY_PTR peer), (ctx, peer)) \
+DEFINEFUNC(int, EVP_PKEY_derive, (GO_EVP_PKEY_CTX_PTR ctx, unsigned char *key, size_t *keylen), (ctx, key, keylen)) \
+DEFINEFUNC_3_0(GO_EVP_MAC_PTR, EVP_MAC_fetch, (GO_OSSL_LIB_CTX_PTR ctx, const char *algorithm, const char *properties), (ctx, algorithm, properties)) \
+DEFINEFUNC_3_0(void, EVP_MAC_free, (GO_EVP_MAC_PTR mac), (mac)) \
+DEFINEFUNC_3_0(GO_EVP_MAC_CTX_PTR, EVP_MAC_CTX_new, (GO_EVP_MAC_PTR arg0), (arg0)) \
+DEFINEFUNC_3_0(void, EVP_MAC_CTX_free, (GO_EVP_MAC_CTX_PTR arg0), (arg0)) \
+DEFINEFUNC_3_0(GO_EVP_MAC_CTX_PTR, EVP_MAC_CTX_dup, (const GO_EVP_MAC_CTX_PTR arg0), (arg0)) \
+DEFINEFUNC_3_0(int, EVP_MAC_init, (GO_EVP_MAC_CTX_PTR ctx, const unsigned char *key, size_t keylen, const OSSL_PARAM params[]), (ctx, key, keylen, params)) \
+DEFINEFUNC_3_0(int, EVP_MAC_update, (GO_EVP_MAC_CTX_PTR ctx, const unsigned char *data, size_t datalen), (ctx, data, datalen)) \
+DEFINEFUNC_3_0(int, EVP_MAC_final, (GO_EVP_MAC_CTX_PTR ctx, unsigned char *out, size_t *outl, size_t outsize), (ctx, out, outl, outsize)) \
+DEFINEFUNC_3_0(OSSL_PARAM, OSSL_PARAM_construct_utf8_string, (const char *key, char *buf, size_t bsize), (key, buf, bsize)) \
+DEFINEFUNC_3_0(OSSL_PARAM, OSSL_PARAM_construct_end, (void), ()) \
+DEFINEFUNC_3_0(int, EVP_PKEY_CTX_set0_rsa_oaep_label, (GO_EVP_PKEY_CTX_PTR ctx, void *label, int len), (ctx, label, len)) \
+
diff --git a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/rsa.go b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/rsa.go
index 05ff62cd73..b717ea932c 100644
--- a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/rsa.go
+++ b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/rsa.go
@@ -13,13 +13,12 @@ import (
 	"crypto/subtle"
 	"errors"
 	"hash"
-	"math/big"
 	"runtime"
 	"unsafe"
 )
 
-func GenerateKeyRSA(bits int) (N, E, D, P, Q, Dp, Dq, Qinv *big.Int, err error) {
-	bad := func(e error) (N, E, D, P, Q, Dp, Dq, Qinv *big.Int, err error) {
+func GenerateKeyRSA(bits int) (N, E, D, P, Q, Dp, Dq, Qinv BigInt, err error) {
+	bad := func(e error) (N, E, D, P, Q, Dp, Dq, Qinv BigInt, err error) {
 		return nil, nil, nil, nil, nil, nil, nil, nil, e
 	}
 	pkey, err := generateEVPPKey(C.GO_EVP_PKEY_RSA, bits, "")
@@ -31,6 +30,7 @@ func GenerateKeyRSA(bits int) (N, E, D, P, Q, Dp, Dq, Qinv *big.Int, err error)
 	if key == nil {
 		return bad(newOpenSSLError("EVP_PKEY_get1_RSA failed"))
 	}
+	defer C.go_openssl_RSA_free(key)
 	N, E, D = rsaGetKey(key)
 	P, Q = rsaGetFactors(key)
 	Dp, Dq, Qinv = rsaGetCRTParams(key)
@@ -42,7 +42,7 @@ type PublicKeyRSA struct {
 	_pkey C.GO_EVP_PKEY_PTR
 }
 
-func NewPublicKeyRSA(N, E *big.Int) (*PublicKeyRSA, error) {
+func NewPublicKeyRSA(N, E BigInt) (*PublicKeyRSA, error) {
 	key := C.go_openssl_RSA_new()
 	if key == nil {
 		return nil, newOpenSSLError("RSA_new failed")
@@ -82,7 +82,7 @@ type PrivateKeyRSA struct {
 	_pkey C.GO_EVP_PKEY_PTR
 }
 
-func NewPrivateKeyRSA(N, E, D, P, Q, Dp, Dq, Qinv *big.Int) (*PrivateKeyRSA, error) {
+func NewPrivateKeyRSA(N, E, D, P, Q, Dp, Dq, Qinv BigInt) (*PrivateKeyRSA, error) {
 	key := C.go_openssl_RSA_new()
 	if key == nil {
 		return nil, newOpenSSLError("RSA_new failed")
@@ -128,23 +128,31 @@ func (k *PrivateKeyRSA) withKey(f func(C.GO_EVP_PKEY_PTR) C.int) C.int {
 }
 
 func DecryptRSAOAEP(h hash.Hash, priv *PrivateKeyRSA, ciphertext, label []byte) ([]byte, error) {
-	return evpDecrypt(priv.withKey, C.GO_RSA_PKCS1_OAEP_PADDING, h, label, ciphertext)
+	return evpDecrypt(priv.withKey, C.GO_RSA_PKCS1_OAEP_PADDING, h, nil, label, ciphertext)
 }
 
 func EncryptRSAOAEP(h hash.Hash, pub *PublicKeyRSA, msg, label []byte) ([]byte, error) {
-	return evpEncrypt(pub.withKey, C.GO_RSA_PKCS1_OAEP_PADDING, h, label, msg)
+	return evpEncrypt(pub.withKey, C.GO_RSA_PKCS1_OAEP_PADDING, h, nil, label, msg)
+}
+
+func DecryptRSAOAEPWithMGF1Hash(h, mgfHash hash.Hash, priv *PrivateKeyRSA, ciphertext, label []byte) ([]byte, error) {
+	return evpDecrypt(priv.withKey, C.GO_RSA_PKCS1_OAEP_PADDING, h, mgfHash, label, ciphertext)
+}
+
+func EncryptRSAOAEPWithMGF1Hash(h, mgfHash hash.Hash, pub *PublicKeyRSA, msg, label []byte) ([]byte, error) {
+	return evpEncrypt(pub.withKey, C.GO_RSA_PKCS1_OAEP_PADDING, h, mgfHash, label, msg)
 }
 
 func DecryptRSAPKCS1(priv *PrivateKeyRSA, ciphertext []byte) ([]byte, error) {
-	return evpDecrypt(priv.withKey, C.GO_RSA_PKCS1_PADDING, nil, nil, ciphertext)
+	return evpDecrypt(priv.withKey, C.GO_RSA_PKCS1_PADDING, nil, nil, nil, ciphertext)
 }
 
 func EncryptRSAPKCS1(pub *PublicKeyRSA, msg []byte) ([]byte, error) {
-	return evpEncrypt(pub.withKey, C.GO_RSA_PKCS1_PADDING, nil, nil, msg)
+	return evpEncrypt(pub.withKey, C.GO_RSA_PKCS1_PADDING, nil, nil, nil, msg)
 }
 
 func DecryptRSANoPadding(priv *PrivateKeyRSA, ciphertext []byte) ([]byte, error) {
-	ret, err := evpDecrypt(priv.withKey, C.GO_RSA_NO_PADDING, nil, nil, ciphertext)
+	ret, err := evpDecrypt(priv.withKey, C.GO_RSA_NO_PADDING, nil, nil, nil, ciphertext)
 	if err != nil {
 		return nil, err
 	}
@@ -168,21 +176,47 @@ func DecryptRSANoPadding(priv *PrivateKeyRSA, ciphertext []byte) ([]byte, error)
 }
 
 func EncryptRSANoPadding(pub *PublicKeyRSA, msg []byte) ([]byte, error) {
-	return evpEncrypt(pub.withKey, C.GO_RSA_NO_PADDING, nil, nil, msg)
+	return evpEncrypt(pub.withKey, C.GO_RSA_NO_PADDING, nil, nil, nil, msg)
 }
 
-func SignRSAPSS(priv *PrivateKeyRSA, h crypto.Hash, hashed []byte, saltLen int) ([]byte, error) {
+func saltLength(saltLen int, sign bool) (C.int, error) {
+	// A salt length of -2 is valid in OpenSSL, but not in crypto/rsa, so reject
+	// it, and lengths < -2, before we convert to the OpenSSL sentinel values.
+	if saltLen <= -2 {
+		return 0, errors.New("crypto/rsa: PSSOptions.SaltLength cannot be negative")
+	}
+	// OpenSSL uses sentinel salt length values like Go crypto does,
+	// but the values don't fully match for rsa.PSSSaltLengthAuto (0).
 	if saltLen == 0 {
-		saltLen = -1 // RSA_PSS_SALTLEN_DIGEST
+		if sign {
+			if vMajor == 1 {
+				// OpenSSL 1.x uses -2 to mean maximal size when signing where Go crypto uses 0.
+				return C.GO_RSA_PSS_SALTLEN_MAX_SIGN, nil
+			}
+			// OpenSSL 3.x deprecated RSA_PSS_SALTLEN_MAX_SIGN
+			// and uses -3 to mean maximal size when signing where Go crypto uses 0.
+			return C.GO_RSA_PSS_SALTLEN_MAX, nil
+		}
+		// OpenSSL uses -2 to mean auto-detect size when verifying where Go crypto uses 0.
+		return C.GO_RSA_PSS_SALTLEN_AUTO, nil
 	}
-	return evpSign(priv.withKey, C.GO_RSA_PKCS1_PSS_PADDING, saltLen, h, hashed)
+	return C.int(saltLen), nil
+}
+
+func SignRSAPSS(priv *PrivateKeyRSA, h crypto.Hash, hashed []byte, saltLen int) ([]byte, error) {
+	cSaltLen, err := saltLength(saltLen, true)
+	if err != nil {
+		return nil, err
+	}
+	return evpSign(priv.withKey, C.GO_RSA_PKCS1_PSS_PADDING, cSaltLen, h, hashed)
 }
 
 func VerifyRSAPSS(pub *PublicKeyRSA, h crypto.Hash, hashed, sig []byte, saltLen int) error {
-	if saltLen == 0 {
-		saltLen = -2 // RSA_PSS_SALTLEN_AUTO
+	cSaltLen, err := saltLength(saltLen, false)
+	if err != nil {
+		return err
 	}
-	return evpVerify(pub.withKey, C.GO_RSA_PKCS1_PSS_PADDING, saltLen, h, sig, hashed)
+	return evpVerify(pub.withKey, C.GO_RSA_PKCS1_PSS_PADDING, cSaltLen, h, sig, hashed)
 }
 
 func SignRSAPKCS1v15(priv *PrivateKeyRSA, h crypto.Hash, hashed []byte) ([]byte, error) {
@@ -213,7 +247,7 @@ type rsa_st_1_0_2 struct {
 	// It contains more fields, but we are not interesed on them.
 }
 
-func bnSet(b1 *C.GO_BIGNUM_PTR, b2 *big.Int) {
+func bnSet(b1 *C.GO_BIGNUM_PTR, b2 BigInt) {
 	if b2 == nil {
 		return
 	}
@@ -223,7 +257,7 @@ func bnSet(b1 *C.GO_BIGNUM_PTR, b2 *big.Int) {
 	*b1 = bigToBN(b2)
 }
 
-func rsaSetKey(key C.GO_RSA_PTR, n, e, d *big.Int) bool {
+func rsaSetKey(key C.GO_RSA_PTR, n, e, d BigInt) bool {
 	if vMajor == 1 && vMinor == 0 {
 		r := (*rsa_st_1_0_2)(unsafe.Pointer(key))
 		//r.d and d will be nil for public keys.
@@ -239,7 +273,7 @@ func rsaSetKey(key C.GO_RSA_PTR, n, e, d *big.Int) bool {
 	return C.go_openssl_RSA_set0_key(key, bigToBN(n), bigToBN(e), bigToBN(d)) == 1
 }
 
-func rsaSetFactors(key C.GO_RSA_PTR, p, q *big.Int) bool {
+func rsaSetFactors(key C.GO_RSA_PTR, p, q BigInt) bool {
 	if vMajor == 1 && vMinor == 0 {
 		r := (*rsa_st_1_0_2)(unsafe.Pointer(key))
 		if (r.p == nil && p == nil) ||
@@ -253,7 +287,7 @@ func rsaSetFactors(key C.GO_RSA_PTR, p, q *big.Int) bool {
 	return C.go_openssl_RSA_set0_factors(key, bigToBN(p), bigToBN(q)) == 1
 }
 
-func rsaSetCRTParams(key C.GO_RSA_PTR, dmp1, dmq1, iqmp *big.Int) bool {
+func rsaSetCRTParams(key C.GO_RSA_PTR, dmp1, dmq1, iqmp BigInt) bool {
 	if vMajor == 1 && vMinor == 0 {
 		r := (*rsa_st_1_0_2)(unsafe.Pointer(key))
 		if (r.dmp1 == nil && dmp1 == nil) ||
@@ -269,7 +303,7 @@ func rsaSetCRTParams(key C.GO_RSA_PTR, dmp1, dmq1, iqmp *big.Int) bool {
 	return C.go_openssl_RSA_set0_crt_params(key, bigToBN(dmp1), bigToBN(dmq1), bigToBN(iqmp)) == 1
 }
 
-func rsaGetKey(key C.GO_RSA_PTR) (*big.Int, *big.Int, *big.Int) {
+func rsaGetKey(key C.GO_RSA_PTR) (BigInt, BigInt, BigInt) {
 	var n, e, d C.GO_BIGNUM_PTR
 	if vMajor == 1 && vMinor == 0 {
 		r := (*rsa_st_1_0_2)(unsafe.Pointer(key))
@@ -280,7 +314,7 @@ func rsaGetKey(key C.GO_RSA_PTR) (*big.Int, *big.Int, *big.Int) {
 	return bnToBig(n), bnToBig(e), bnToBig(d)
 }
 
-func rsaGetFactors(key C.GO_RSA_PTR) (*big.Int, *big.Int) {
+func rsaGetFactors(key C.GO_RSA_PTR) (BigInt, BigInt) {
 	var p, q C.GO_BIGNUM_PTR
 	if vMajor == 1 && vMinor == 0 {
 		r := (*rsa_st_1_0_2)(unsafe.Pointer(key))
@@ -291,7 +325,7 @@ func rsaGetFactors(key C.GO_RSA_PTR) (*big.Int, *big.Int) {
 	return bnToBig(p), bnToBig(q)
 }
 
-func rsaGetCRTParams(key C.GO_RSA_PTR) (*big.Int, *big.Int, *big.Int) {
+func rsaGetCRTParams(key C.GO_RSA_PTR) (BigInt, BigInt, BigInt) {
 	var dmp1, dmq1, iqmp C.GO_BIGNUM_PTR
 	if vMajor == 1 && vMinor == 0 {
 		r := (*rsa_st_1_0_2)(unsafe.Pointer(key))
diff --git a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/sha.go b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/sha.go
index c5b0189efc..cdd216423b 100644
--- a/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/sha.go
+++ b/src/vendor/github.com/microsoft/go-crypto-openssl/openssl/sha.go
@@ -17,6 +17,91 @@ import (
 	"unsafe"
 )
 
+// NOTE: Implementation ported from https://go-review.googlesource.com/c/go/+/404295.
+// The cgo calls in this file are arranged to avoid marking the parameters as escaping.
+// To do that, we call noescape (including via addr).
+// We must also make sure that the data pointer arguments have the form unsafe.Pointer(&...)
+// so that cgo does not annotate them with cgoCheckPointer calls. If it did that, it might look
+// beyond the byte slice and find Go pointers in unprocessed parts of a larger allocation.
+// To do both of these simultaneously, the idiom is unsafe.Pointer(&*addr(p)),
+// where addr returns the base pointer of p, substituting a non-nil pointer for nil,
+// and applying a noescape along the way.
+// This is all to preserve compatibility with the allocation behavior of the non-openssl implementations.
+
+func shaX(md C.GO_EVP_MD_PTR, p []byte, sum []byte) bool {
+	return C.go_shaX(md, unsafe.Pointer(&*addr(p)), C.size_t(len(p)), noescape(unsafe.Pointer(&sum[0]))) != 0
+}
+
+func SHA1(p []byte) (sum [20]byte) {
+	if !shaX(C.go_openssl_EVP_sha1(), p, sum[:]) {
+		panic("openssl: SHA1 failed")
+	}
+	return
+}
+
+func SHA224(p []byte) (sum [28]byte) {
+	if !shaX(C.go_openssl_EVP_sha224(), p, sum[:]) {
+		panic("openssl: SHA224 failed")
+	}
+	return
+}
+
+func SHA256(p []byte) (sum [32]byte) {
+	if !shaX(C.go_openssl_EVP_sha256(), p, sum[:]) {
+		panic("openssl: SHA256 failed")
+	}
+	return
+}
+
+func SHA384(p []byte) (sum [48]byte) {
+	if !shaX(C.go_openssl_EVP_sha384(), p, sum[:]) {
+		panic("openssl: SHA384 failed")
+	}
+	return
+}
+
+func SHA512(p []byte) (sum [64]byte) {
+	if !shaX(C.go_openssl_EVP_sha512(), p, sum[:]) {
+		panic("openssl: SHA512 failed")
+	}
+	return
+}
+
+// Same as SupportsHKDF, as in v1.1.1+
+func SupportsSHA3() bool {
+	return vMajor > 1 ||
+		(vMajor >= 1 && vMinor > 1) ||
+		(vMajor >= 1 && vMinor >= 1 && vFeature >= 1)
+}
+
+func SHA3_224(p []byte) (sum [28]byte) {
+	if !shaX(C.go_openssl_EVP_sha3_224(), p, sum[:]) {
+		panic("openssl: SHA3_224 failed")
+	}
+	return
+}
+
+func SHA3_256(p []byte) (sum [32]byte) {
+	if !shaX(C.go_openssl_EVP_sha3_256(), p, sum[:]) {
+		panic("openssl: SHA3_256 failed")
+	}
+	return
+}
+
+func SHA3_384(p []byte) (sum [48]byte) {
+	if !shaX(C.go_openssl_EVP_sha3_384(), p, sum[:]) {
+		panic("openssl: SHA3_384 failed")
+	}
+	return
+}
+
+func SHA3_512(p []byte) (sum [64]byte) {
+	if !shaX(C.go_openssl_EVP_sha3_512(), p, sum[:]) {
+		panic("openssl: SHA3_512 failed")
+	}
+	return
+}
+
 type evpHash struct {
 	md  C.GO_EVP_MD_PTR
 	ctx C.GO_EVP_MD_CTX_PTR
@@ -55,8 +140,8 @@ func (h *evpHash) finalize() {
 func (h *evpHash) Reset() {
 	// There is no need to reset h.ctx2 because it is always reset after
 	// use in evpHash.sum.
-	C.go_openssl_EVP_MD_CTX_reset(h.ctx)
-
+	// Calling EVP_DigestInit on an already initialized EVP_MD_CTX results in
+	// memory leak on OpenSSL 1.0.2, use EVP_DigestInit_ex  instead.
 	if C.go_openssl_EVP_DigestInit_ex(h.ctx, h.md, nil) != 1 {
 		panic("openssl: EVP_DigestInit_ex failed")
 	}
@@ -64,13 +149,35 @@ func (h *evpHash) Reset() {
 }
 
 func (h *evpHash) Write(p []byte) (int, error) {
-	if len(p) > 0 && C.go_openssl_EVP_DigestUpdate(h.ctx, unsafe.Pointer(&p[0]), C.size_t(len(p))) != 1 {
+	if len(p) > 0 && C.go_openssl_EVP_DigestUpdate(h.ctx, unsafe.Pointer(&*addr(p)), C.size_t(len(p))) != 1 {
 		panic("openssl: EVP_DigestUpdate failed")
 	}
 	runtime.KeepAlive(h)
 	return len(p), nil
 }
 
+func (h *evpHash) WriteString(s string) (int, error) {
+	// TODO: use unsafe.StringData once we drop support
+	// for go1.19 and earlier.
+	hdr := (*struct {
+		Data *byte
+		Len  int
+	})(unsafe.Pointer(&s))
+	if len(s) > 0 && C.go_openssl_EVP_DigestUpdate(h.ctx, unsafe.Pointer(hdr.Data), C.size_t(len(s))) == 0 {
+		panic("openssl: EVP_DigestUpdate failed")
+	}
+	runtime.KeepAlive(h)
+	return len(s), nil
+}
+
+func (h *evpHash) WriteByte(c byte) error {
+	if C.go_openssl_EVP_DigestUpdate(h.ctx, unsafe.Pointer(&c), 1) == 0 {
+		panic("openssl: EVP_DigestUpdate failed")
+	}
+	runtime.KeepAlive(h)
+	return nil
+}
+
 func (h *evpHash) Size() int {
 	return h.size
 }
@@ -84,14 +191,12 @@ func (h *evpHash) sum(out []byte) {
 	// that Sum has no effect on the underlying stream.
 	// In particular it is OK to Sum, then Write more, then Sum again,
 	// and the second Sum acts as if the first didn't happen.
-	C.go_openssl_EVP_DigestInit_ex(h.ctx2, h.md, nil)
-	if C.go_openssl_EVP_MD_CTX_copy_ex(h.ctx2, h.ctx) != 1 {
-		panic("openssl: EVP_MD_CTX_copy_ex failed")
+	if C.go_openssl_EVP_MD_CTX_copy(h.ctx2, h.ctx) != 1 {
+		panic("openssl: EVP_MD_CTX_copy failed")
 	}
-	if C.go_openssl_EVP_DigestFinal_ex(h.ctx2, base(out), nil) != 1 {
-		panic("openssl: EVP_DigestFinal_ex failed")
+	if C.go_openssl_EVP_DigestFinal(h.ctx2, (*C.uchar)(noescape(unsafe.Pointer(base(out)))), nil) != 1 {
+		panic("openssl: EVP_DigestFinal failed")
 	}
-	C.go_openssl_EVP_MD_CTX_reset(h.ctx2)
 	runtime.KeepAlive(h)
 }
 
@@ -499,6 +604,74 @@ func (h *sha512Hash) UnmarshalBinary(b []byte) error {
 	return nil
 }
 
+// NewSHA3_224 returns a new SHA3-224 hash.
+func NewSHA3_224() hash.Hash {
+	return &sha3_224Hash{
+		evpHash: newEvpHash(crypto.SHA3_224, 224/8, 64),
+	}
+}
+
+type sha3_224Hash struct {
+	*evpHash
+	out [224 / 8]byte
+}
+
+func (h *sha3_224Hash) Sum(in []byte) []byte {
+	h.sum(h.out[:])
+	return append(in, h.out[:]...)
+}
+
+// NewSHA3_256 returns a new SHA3-256 hash.
+func NewSHA3_256() hash.Hash {
+	return &sha3_256Hash{
+		evpHash: newEvpHash(crypto.SHA3_256, 256/8, 64),
+	}
+}
+
+type sha3_256Hash struct {
+	*evpHash
+	out [256 / 8]byte
+}
+
+func (h *sha3_256Hash) Sum(in []byte) []byte {
+	h.sum(h.out[:])
+	return append(in, h.out[:]...)
+}
+
+// NewSHA3_384 returns a new SHA3-384 hash.
+func NewSHA3_384() hash.Hash {
+	return &sha3_384Hash{
+		evpHash: newEvpHash(crypto.SHA3_384, 384/8, 128),
+	}
+}
+
+type sha3_384Hash struct {
+	*evpHash
+	out [384 / 8]byte
+}
+
+func (h *sha3_384Hash) Sum(in []byte) []byte {
+	h.sum(h.out[:])
+	return append(in, h.out[:]...)
+}
+
+// NewSHA3_512 returns a new SHA3-512 hash.
+func NewSHA3_512() hash.Hash {
+	return &sha3_512Hash{
+		evpHash: newEvpHash(crypto.SHA3_512, 512/8, 128),
+	}
+}
+
+type sha3_512Hash struct {
+	*evpHash
+	out [512 / 8]byte
+}
+
+func (h *sha3_512Hash) Sum(in []byte) []byte {
+	h.sum(h.out[:])
+	return append(in, h.out[:]...)
+}
+
 // appendUint64 appends x into b as a big endian byte sequence.
 func appendUint64(b []byte, x uint64) []byte {
 	return append(b,
diff --git a/src/vendor/modules.txt b/src/vendor/modules.txt
index c31f65cd61..75b78bfb94 100644
--- a/src/vendor/modules.txt
+++ b/src/vendor/modules.txt
@@ -1,6 +1,8 @@
-# github.com/microsoft/go-crypto-openssl v0.1.2
-## explicit; go 1.16
+# github.com/microsoft/go-crypto-openssl v0.2.8 => github.com/xnox/go-crypto-openssl v0.2.9-0.20230701230530-84b71a4b45db
+## explicit; go 1.17
 github.com/microsoft/go-crypto-openssl/openssl
+github.com/microsoft/go-crypto-openssl/openssl/bbig
+github.com/microsoft/go-crypto-openssl/openssl/bbig/bridge
 github.com/microsoft/go-crypto-openssl/openssl/internal/subtle
 # golang.org/x/crypto v0.0.0-20211215153901-e495a2d5b3d3
 ## explicit; go 1.17
-- 
2.34.1

